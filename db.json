{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/timg.png","path":"img/timg.png","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/topbg.jpg","path":"img/header_img/topbg.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/sing-zxm.png","path":"img/signature/sing-zxm.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":1,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/home.jpeg","path":"img/home.jpeg","modified":1,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":1,"renderable":0},{"_id":"source/img/header_img/main-video.mp4","path":"img/header_img/main-video.mp4","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"95a2e486d29a05fb53ed2a1d415dea08b98ea008","modified":1547532891725},{"_id":"source/CNAME","hash":"5ad9f6992b42487900b7398afe6065f0f62aeceb","modified":1545967603237},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1535613639000},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1535613639000},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1535614089000},{"_id":"source/_posts/.DS_Store","hash":"3e975ad42fe5003056bb08420f1d1af2496d300b","modified":1547617703298},{"_id":"source/_posts/HTTP-1.md","hash":"58ad1f73b8ec855a96d61566d261e9015b66fd35","modified":1547532806311},{"_id":"source/_posts/HTTP-2.md","hash":"5ab782310d41883344aac55aa0ad6b379ab0d983","modified":1547532225459},{"_id":"source/_posts/HTTP-3.md","hash":"8cd251dc4fddc03c9308235b01e054fab5a8b2ed","modified":1547617955469},{"_id":"source/_posts/first-blog.md","hash":"d325aa19bfd81bc74524a2845eaf6dba79ef6dae","modified":1545963027133},{"_id":"source/_posts/React.md","hash":"357acec1cf95297cf6d35fefbc4afb7a8c7858e3","modified":1546062869035},{"_id":"source/_posts/future.md","hash":"c3becb4e9ad943dff7c5b12c4d6d3e0808ebcfbe","modified":1547003906833},{"_id":"source/_posts/localCompareBug.md","hash":"0c106521215195aac833c38521b58d7d7a0efd8e","modified":1547532220123},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1535613639000},{"_id":"source/img/.DS_Store","hash":"02ef2d218a3bcb25eafd2e358d8c6ba234965131","modified":1547532924834},{"_id":"source/about/index.md","hash":"95ae0ca5ca53348b46b9167308a3b49bf5b9902f","modified":1544779683619},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1535613639000},{"_id":"source/img/timg.png","hash":"b6e6f2d2cef30a3e23dac0047b50ec8332f86eb2","modified":1535627583000},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1535613639000},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1535613639000},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1535613639000},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1535613639000},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1535613639000},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1535613639000},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1535613639000},{"_id":"themes/beantech/layout/layout.ejs","hash":"6efee96baaeb079b0abb2642c8d64edf01946a2e","modified":1544780615457},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1535613639000},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1535613639000},{"_id":"themes/beantech/layout/post.ejs","hash":"81e10c56b03379dc17d553b9622323b4d996df96","modified":1547532486548},{"_id":"source/_posts/HTTP-1/.DS_Store","hash":"8a479b924c98233592af564a6762c13fc3f7558e","modified":1547532880885},{"_id":"source/_posts/HTTP-2/.DS_Store","hash":"8b86c52ff2717b92d959498f4e2a70e12c5b7366","modified":1547532940625},{"_id":"source/_posts/HTTP-3/.DS_Store","hash":"6ccb0ff89706c1eb1561cbd060b0ae66a042c32d","modified":1547617742457},{"_id":"source/img/header_img/.DS_Store","hash":"f3830d3fb8377daf4ae2676717d8841da96c708d","modified":1544781932342},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1535613639000},{"_id":"source/img/header_img/topbg.jpg","hash":"1202404244a65a3666c27dd564f715744c3b557b","modified":1535357068000},{"_id":"source/img/signature/sing-zxm.png","hash":"95342d85a675d957652df6dc58188fbc570a47fb","modified":1544780331979},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"8c9a3faf215019be61dfaed7597f5287f5423b65","modified":1535616229000},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"cf64ad851dd34f9cdc5115738b04da682a7315ec","modified":1535681036000},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1535613639000},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"9db05bc046a6cd5a7f9aa6b79b6033966e6e19da","modified":1544782217389},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1535613639000},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1535613639000},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1535613639000},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1535613639000},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1535613639000},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1535613639000},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1535613639000},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1535613639000},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1535613639000},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1535613639000},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1535613639000},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1535613639000},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1535613639000},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1535613639000},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1535613639000},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1535613639000},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1535613639000},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1535613639000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1535613639000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1535613639000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1535613639000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1535613639000},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1535613639000},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1535613639000},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1535613639000},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1535613639000},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1535613639000},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1535613639000},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1535613639000},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1535613639000},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1535613639000},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1535613639000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1535613639000},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1535613639000},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1535613639000},{"_id":"source/_posts/HTTP-1/img/.DS_Store","hash":"217c029bfc1ee8cb07a386589fa24843bce72825","modified":1547532933523},{"_id":"source/_posts/HTTP-1/img/http-1.jpeg","hash":"de0457321b4169d75f91a6350db1ed715b860623","modified":1547109060027},{"_id":"source/_posts/HTTP-1/img/http-7.jpeg","hash":"88e7b6573e9454aba62b934eaeedfcbb44c25d14","modified":1547109060026},{"_id":"source/_posts/HTTP-2/img/.DS_Store","hash":"b6fbce13fb81e2fbb7b6426303629805bda1b1de","modified":1547532940623},{"_id":"source/_posts/HTTP-2/img/1.jpeg","hash":"e9c7e51e0f7ce2f9e5c622615fa5571e890b6a48","modified":1547531997501},{"_id":"source/_posts/HTTP-2/img/2.jpeg","hash":"e25b2a5486f961eebff9fd81df9f43ee885483b1","modified":1547531997500},{"_id":"source/_posts/HTTP-3/img/1.jpeg","hash":"fece7689f41479e5861b9f010b1eba5897d45cb8","modified":1547606552400},{"_id":"source/_posts/HTTP-3/img/4.jpeg","hash":"e15a3156a84d8a7a0f4113b34880df25a35d2c60","modified":1547609470992},{"_id":"source/_posts/HTTP-3/img/2.jpeg","hash":"279081900c9d11ab0ed4c66653cd144db213a6c5","modified":1547606563431},{"_id":"source/_posts/HTTP-3/img/5.jpeg","hash":"f1b59174f65974960b8fcd8ab0c16529e5d63c70","modified":1547609718433},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1535613639000},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1535613639000},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1535613639000},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1535613639000},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1535613639000},{"_id":"source/_posts/HTTP-1/img/http-3.jpeg","hash":"d628f6efe65b4528abfd947ebff6131a38a20743","modified":1547109060026},{"_id":"source/_posts/HTTP-1/img/http-2.jpeg","hash":"5a1f967762047d506c6bcd36169fec40e78bde92","modified":1547109060026},{"_id":"source/_posts/HTTP-1/img/http-5.jpeg","hash":"ea7fdcf4621f7898bfd778a11a023c3462346a01","modified":1547109060026},{"_id":"source/_posts/HTTP-1/img/http-4.jpeg","hash":"0ebfb29346a1758b9da418d85b17efab4ae92d7d","modified":1547109060026},{"_id":"source/_posts/HTTP-1/img/http-6.jpeg","hash":"2beebde8fb8dfba4b1866e17f86aa81e9085dc2d","modified":1547109060026},{"_id":"source/_posts/HTTP-2/img/3.jpeg","hash":"68ef4521e4c1a7629911f2e95fb427bc3ede70ff","modified":1547531997500},{"_id":"source/_posts/HTTP-2/img/4.jpeg","hash":"0067498233c7e1c36809988e5a3c2661c4470306","modified":1547531997500},{"_id":"source/_posts/HTTP-2/img/5.jpeg","hash":"a267bea947ea4da305ee35cd4fb7c7c12ac8a91e","modified":1547531997501},{"_id":"source/_posts/HTTP-3/img/6.jpeg","hash":"e13b59c674fa5772723907204e1acead72291624","modified":1547610848423},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1535613639000},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1535613639000},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1535613639000},{"_id":"source/_posts/HTTP-1/img/http-8.jpeg","hash":"f59886411e40755b2dc8668ea99af1864a08470a","modified":1547109292838},{"_id":"source/_posts/HTTP-3/img/3.jpeg","hash":"435153a0b283e21920804940113e2dfc7e06a54a","modified":1547606607878},{"_id":"source/_posts/first-blog/img/header_img/heye.jpg","hash":"3435cfb171e426f35a12687312169c8fefa56913","modified":1545962073025},{"_id":"source/_posts/React/img/header_img/sky.jpg","hash":"29bdfb4c7d38ffe543e8631c31fe85763b1cfcbd","modified":1545962065843},{"_id":"source/img/home.jpeg","hash":"184ac3a1383b4eec27722ade26d89bef1539d86d","modified":1547520953504},{"_id":"source/_posts/HTTP-1/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1535613639000},{"_id":"source/_posts/HTTP-2/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1535613639000},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1535613639000},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1535613639000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1535613639000},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1535613639000},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1535613639000},{"_id":"source/img/header_img/main-video.mp4","hash":"d677d408a21db85c1cbcb0bdfd935f2ab611a240","modified":1544781843462}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-12-13T06:09:34.636Z","updated":"2018-08-30T07:20:39.000Z","path":"404.html","title":"","comments":1,"_id":"cjqyrrxbo0000czhqjn7hrdtc","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-08-30T07:20:39.000Z","path":"archive/index.html","_id":"cjqyrrxdy0002czhqd64nwcof","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/tf-logo-dark.png","comments":1,"_content":"\n> 美丽的空想抵不上踏实的做事，只要开始做事，就算再晚也不迟。\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/tf-logo-dark.png\"\ncomments: true\n---\n\n> 美丽的空想抵不上踏实的做事，只要开始做事，就算再晚也不迟。\n","updated":"2018-12-14T09:28:03.619Z","path":"about/index.html","_id":"cjqyrrxe10004czhqm249fzy9","content":"<blockquote>\n<p>美丽的空想抵不上踏实的做事，只要开始做事，就算再晚也不迟。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>美丽的空想抵不上踏实的做事，只要开始做事，就算再晚也不迟。</p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-12-13T06:09:34.622Z","updated":"2018-08-30T07:20:39.000Z","path":"tags/index.html","comments":1,"_id":"cjqyrrxe70007czhq5aocauw4","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"《图解HTTP》学习笔记 之 第一篇：了解Web及网络基础","catalog":true,"date":"2019-01-10T08:21:40.000Z","subtitle":"了解Web及网络基础","header-img":"img/header_img/tf-logo-dark.png","catagories":["HTTP"],"_content":"\n## 第一篇:了解Web及网络基础\n\n------\n\n### 1.web是建立在何种技术之上？\n\n当我们再网页浏览器的地址栏输入URL时，web浏览器从web服务器获取文件资源等信息，从而显示出web页面。\n\nweb使用一种名为HTTP（超文本传输协议） 的协议作为规范，完成从客户端到服务端等一系列运作流程。可以说，web是建立在HTTP协议上通信的。\n\n\n### 2.网络基础 TCP/IP\n为了理解HTTP，我们有必要了解一下TCP/IP协议族。\n\n通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。\n\n#### **2.1 TCP/IP 协议族**\n\n计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则成为协议。\n\n![TCP/IP](img/http-1.jpeg)\n图：TCP/IP是互联网相关的各协议族的总称\n\n协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤等。\n\n像这样把与互联网相关联的协议集合起来总称为TCP/IP。\n\n####  **2.2 TCP/IP 的分层管理**\n\nTCP/IP 协议族里重要的一点就是分层。\n\n- 应用层\n- 传输层\n- 网络层\n- 数据链路层\n\n**TCP/IP协议族各层的作用如下：**\n\n> ***应用层：***\n\n应用层决定了向用户提供应用服务时通信的活动。\nTCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol,文件传输协议）和DNS（Domain Name System,域名系统）服务就是其中两类。\n\nHTTP 协议也处于该层\n\n> ***传输层：***\n\n传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。\n\n在传输层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）。\n\n> ***网络层：***\n\n网络层用来处理在网上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。\n\n与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。\n\n> ***链路层：（又名数据链路层，网络接口层）***\n\n用来处理链接网络的硬件部分。包括控制 操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。\n\n#### **2.3 TCP/IP通信传输流**\n\n![通信传输流](img/http-2.jpeg)\n利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往应用层上走。\n\n接着，为了传输方便，在传输层（TCP协议）把从应用层处接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n\n在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。\n\n接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。\n\n![通信传输流包含首部信息](img/http-3.jpeg)\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。\n\n> 这种把数据信息包装起来的做法成为封装。\n\n### 3.与HTTP关系密切的协议：IP、TCP和DNS\n\n#### **负责传输的IP协议**\n\n按层次分，IP 网际协议位于网络层。几乎所有的使用网络的系统都会用到IP协议。可能有人会把\"IP\"和\"IP地址\"搞混，\"IP\"其实是一种协议的名称。\n\nIP协议的作用是把各种数据包传输给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。\n\nIP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会改变。\n\n> 使用ARP协议凭借MAC地址进行通信\n\nIP间的通信依赖MAC地址。在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。\n\n> 没人能全面掌握互联网中的传输状况\n\n在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。\n\n这种机制称为路由选择，有点像快递公司的送货过程。我们只知道具体用的什么快递，在哪中转站，倒是不知道具体走的什么路线，用的什么工具等等。\n\n![IP传输过程](img/http-4.jpeg)\n\n#### 确保可靠性的TCP协议\n\n按层次分，TCP位于传输层，提供可靠的字节流服务。\n\n所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。\n\n> 确保数据能达到目标\n\n为了准确无误地将数据传送到目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志SYN和ACK\n\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。\n\n![DNS解析](img/http-5.jpeg)\n\n若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n### 4.负责域名解析的DNS服务\n\nDNS 服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。\n\n用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的习惯。\n\n![DNS解析](img/http-6.jpeg)\n\n### 5.各种协议与HTTP协议的关系\n\n我们可以通过这张图来了解下IP协议、TCP协议、和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用\n\n![各种协议的关系](img/http-8.jpeg)\n\n\n### 6.URI和URL\n\n与URI（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。URL正是使用WEB浏览器等访问WEB页面时需要输入的网页地址。\n\n#### 统一资源标识符\n\nURI是Uniform Resource Identifier 的缩写。\n\n> Uniform\n\n规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。\n\n> Resource\n\n资源的定义是“可标示的任何东西”。除了文档文件、图像或服务等能够区别于其他类型的，全都可作为资源。另外，资源不仅仅可以是单一的，也可以说是多数的集合体。\n\n> Identifier \n\n表示可标识的对象。也成为标识符。\n\n> **综上所述,URI就是由某个协议方案标识的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。**\n\nURI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。\n\n#### URI格式\n\n![URI格式](img/http-7.jpeg)\n\n> 登录信息\n\n指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是可选。\n\n> 服务器地址\n\n使用绝对URI 必须指定待访问的服务器地址。\n\n> 服务器端口号\n\n指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n\n> 带层次的文件路径\n\n指定服务器上的文件路径来定位特指的资源。\n\n> 查询字符串\n\n针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项可选。\n\n> 片段标识符\n\n使用片段标识符通常可标记出已获取资源中的子资源。但在RFC中并没有明确规定其使用方法。该项可选。\n\n> 写在最后\n\n因为本身写博客比较少，写作能力又有点弱。又特别想把看过的东西写下来，所以这篇博客大部分都是按着原书上的字用键盘打出来的。我想也许写的多了慢慢也就会有自己的语言了吧。\n\n\n","source":"_posts/HTTP-1.md","raw":"---\ntitle: 《图解HTTP》学习笔记 之 第一篇：了解Web及网络基础\ncatalog: true\ndate: 2019-01-10 16:21:40\nsubtitle: 了解Web及网络基础\nheader-img: \"img/header_img/tf-logo-dark.png\"\ntags: \n- 图解HTTP\ncatagories:\n- HTTP\n---\n\n## 第一篇:了解Web及网络基础\n\n------\n\n### 1.web是建立在何种技术之上？\n\n当我们再网页浏览器的地址栏输入URL时，web浏览器从web服务器获取文件资源等信息，从而显示出web页面。\n\nweb使用一种名为HTTP（超文本传输协议） 的协议作为规范，完成从客户端到服务端等一系列运作流程。可以说，web是建立在HTTP协议上通信的。\n\n\n### 2.网络基础 TCP/IP\n为了理解HTTP，我们有必要了解一下TCP/IP协议族。\n\n通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。\n\n#### **2.1 TCP/IP 协议族**\n\n计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则成为协议。\n\n![TCP/IP](img/http-1.jpeg)\n图：TCP/IP是互联网相关的各协议族的总称\n\n协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤等。\n\n像这样把与互联网相关联的协议集合起来总称为TCP/IP。\n\n####  **2.2 TCP/IP 的分层管理**\n\nTCP/IP 协议族里重要的一点就是分层。\n\n- 应用层\n- 传输层\n- 网络层\n- 数据链路层\n\n**TCP/IP协议族各层的作用如下：**\n\n> ***应用层：***\n\n应用层决定了向用户提供应用服务时通信的活动。\nTCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol,文件传输协议）和DNS（Domain Name System,域名系统）服务就是其中两类。\n\nHTTP 协议也处于该层\n\n> ***传输层：***\n\n传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。\n\n在传输层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）。\n\n> ***网络层：***\n\n网络层用来处理在网上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。\n\n与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。\n\n> ***链路层：（又名数据链路层，网络接口层）***\n\n用来处理链接网络的硬件部分。包括控制 操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。\n\n#### **2.3 TCP/IP通信传输流**\n\n![通信传输流](img/http-2.jpeg)\n利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往应用层上走。\n\n接着，为了传输方便，在传输层（TCP协议）把从应用层处接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n\n在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。\n\n接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。\n\n![通信传输流包含首部信息](img/http-3.jpeg)\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。\n\n> 这种把数据信息包装起来的做法成为封装。\n\n### 3.与HTTP关系密切的协议：IP、TCP和DNS\n\n#### **负责传输的IP协议**\n\n按层次分，IP 网际协议位于网络层。几乎所有的使用网络的系统都会用到IP协议。可能有人会把\"IP\"和\"IP地址\"搞混，\"IP\"其实是一种协议的名称。\n\nIP协议的作用是把各种数据包传输给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。\n\nIP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会改变。\n\n> 使用ARP协议凭借MAC地址进行通信\n\nIP间的通信依赖MAC地址。在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。\n\n> 没人能全面掌握互联网中的传输状况\n\n在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。\n\n这种机制称为路由选择，有点像快递公司的送货过程。我们只知道具体用的什么快递，在哪中转站，倒是不知道具体走的什么路线，用的什么工具等等。\n\n![IP传输过程](img/http-4.jpeg)\n\n#### 确保可靠性的TCP协议\n\n按层次分，TCP位于传输层，提供可靠的字节流服务。\n\n所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。\n\n> 确保数据能达到目标\n\n为了准确无误地将数据传送到目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志SYN和ACK\n\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。\n\n![DNS解析](img/http-5.jpeg)\n\n若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n### 4.负责域名解析的DNS服务\n\nDNS 服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。\n\n用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的习惯。\n\n![DNS解析](img/http-6.jpeg)\n\n### 5.各种协议与HTTP协议的关系\n\n我们可以通过这张图来了解下IP协议、TCP协议、和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用\n\n![各种协议的关系](img/http-8.jpeg)\n\n\n### 6.URI和URL\n\n与URI（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。URL正是使用WEB浏览器等访问WEB页面时需要输入的网页地址。\n\n#### 统一资源标识符\n\nURI是Uniform Resource Identifier 的缩写。\n\n> Uniform\n\n规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。\n\n> Resource\n\n资源的定义是“可标示的任何东西”。除了文档文件、图像或服务等能够区别于其他类型的，全都可作为资源。另外，资源不仅仅可以是单一的，也可以说是多数的集合体。\n\n> Identifier \n\n表示可标识的对象。也成为标识符。\n\n> **综上所述,URI就是由某个协议方案标识的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。**\n\nURI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。\n\n#### URI格式\n\n![URI格式](img/http-7.jpeg)\n\n> 登录信息\n\n指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是可选。\n\n> 服务器地址\n\n使用绝对URI 必须指定待访问的服务器地址。\n\n> 服务器端口号\n\n指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n\n> 带层次的文件路径\n\n指定服务器上的文件路径来定位特指的资源。\n\n> 查询字符串\n\n针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项可选。\n\n> 片段标识符\n\n使用片段标识符通常可标记出已获取资源中的子资源。但在RFC中并没有明确规定其使用方法。该项可选。\n\n> 写在最后\n\n因为本身写博客比较少，写作能力又有点弱。又特别想把看过的东西写下来，所以这篇博客大部分都是按着原书上的字用键盘打出来的。我想也许写的多了慢慢也就会有自己的语言了吧。\n\n\n","slug":"HTTP-1","published":1,"updated":"2019-01-15T06:13:26.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqyrrxdt0001czhqtry707ix","content":"<h2><span id=\"第一篇了解web及网络基础\">第一篇:了解Web及网络基础</span></h2>\n<hr>\n<h3><span id=\"1web是建立在何种技术之上\">1.web是建立在何种技术之上？</span></h3>\n<p>当我们再网页浏览器的地址栏输入URL时，web浏览器从web服务器获取文件资源等信息，从而显示出web页面。</p>\n<p>web使用一种名为HTTP（超文本传输协议） 的协议作为规范，完成从客户端到服务端等一系列运作流程。可以说，web是建立在HTTP协议上通信的。</p>\n<h3><span id=\"2网络基础-tcpip\">2.网络基础 TCP/IP</span></h3>\n<p>为了理解HTTP，我们有必要了解一下TCP/IP协议族。</p>\n<p>通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。</p>\n<h4><span id=\"21-tcpip-协议族\"><strong>2.1 TCP/IP 协议族</strong></span></h4>\n<p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则成为协议。</p>\n<p><img src=\"img/http-1.jpeg\" alt=\"TCP/IP\"><br>\n图：TCP/IP是互联网相关的各协议族的总称</p>\n<p>协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤等。</p>\n<p>像这样把与互联网相关联的协议集合起来总称为TCP/IP。</p>\n<h4><span id=\"22-tcpip-的分层管理\"><strong>2.2 TCP/IP 的分层管理</strong></span></h4>\n<p>TCP/IP 协议族里重要的一点就是分层。</p>\n<ul>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>数据链路层</li>\n</ul>\n<p><strong>TCP/IP协议族各层的作用如下：</strong></p>\n<blockquote>\n<p><strong><em>应用层：</em></strong></p>\n</blockquote>\n<p>应用层决定了向用户提供应用服务时通信的活动。<br>\nTCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol,文件传输协议）和DNS（Domain Name System,域名系统）服务就是其中两类。</p>\n<p>HTTP 协议也处于该层</p>\n<blockquote>\n<p><strong><em>传输层：</em></strong></p>\n</blockquote>\n<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。</p>\n<p>在传输层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p>\n<blockquote>\n<p><strong><em>网络层：</em></strong></p>\n</blockquote>\n<p>网络层用来处理在网上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p>\n<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>\n<blockquote>\n<p><strong><em>链路层：（又名数据链路层，网络接口层）</em></strong></p>\n</blockquote>\n<p>用来处理链接网络的硬件部分。包括控制 操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</p>\n<h4><span id=\"23-tcpip通信传输流\"><strong>2.3 TCP/IP通信传输流</strong></span></h4>\n<p><img src=\"img/http-2.jpeg\" alt=\"通信传输流\"><br>\n利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往应用层上走。</p>\n<p>接着，为了传输方便，在传输层（TCP协议）把从应用层处接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>\n<p>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。</p>\n<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。</p>\n<p><img src=\"img/http-3.jpeg\" alt=\"通信传输流包含首部信息\"></p>\n<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。</p>\n<blockquote>\n<p>这种把数据信息包装起来的做法成为封装。</p>\n</blockquote>\n<h3><span id=\"3与http关系密切的协议ip-tcp和dns\">3.与HTTP关系密切的协议：IP、TCP和DNS</span></h3>\n<h4><span id=\"负责传输的ip协议\"><strong>负责传输的IP协议</strong></span></h4>\n<p>按层次分，IP 网际协议位于网络层。几乎所有的使用网络的系统都会用到IP协议。可能有人会把&quot;IP&quot;和&quot;IP地址&quot;搞混，&quot;IP&quot;其实是一种协议的名称。</p>\n<p>IP协议的作用是把各种数据包传输给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。</p>\n<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会改变。</p>\n<blockquote>\n<p>使用ARP协议凭借MAC地址进行通信</p>\n</blockquote>\n<p>IP间的通信依赖MAC地址。在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>\n<blockquote>\n<p>没人能全面掌握互联网中的传输状况</p>\n</blockquote>\n<p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。</p>\n<p>这种机制称为路由选择，有点像快递公司的送货过程。我们只知道具体用的什么快递，在哪中转站，倒是不知道具体走的什么路线，用的什么工具等等。</p>\n<p><img src=\"img/http-4.jpeg\" alt=\"IP传输过程\"></p>\n<h4><span id=\"确保可靠性的tcp协议\">确保可靠性的TCP协议</span></h4>\n<p>按层次分，TCP位于传输层，提供可靠的字节流服务。</p>\n<p>所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。</p>\n<blockquote>\n<p>确保数据能达到目标</p>\n</blockquote>\n<p>为了准确无误地将数据传送到目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志SYN和ACK</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p>\n<p><img src=\"img/http-5.jpeg\" alt=\"DNS解析\"></p>\n<p>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>\n<h3><span id=\"4负责域名解析的dns服务\">4.负责域名解析的DNS服务</span></h3>\n<p>DNS 服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p>\n<p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的习惯。</p>\n<p><img src=\"img/http-6.jpeg\" alt=\"DNS解析\"></p>\n<h3><span id=\"5各种协议与http协议的关系\">5.各种协议与HTTP协议的关系</span></h3>\n<p>我们可以通过这张图来了解下IP协议、TCP协议、和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用</p>\n<p><img src=\"img/http-8.jpeg\" alt=\"各种协议的关系\"></p>\n<h3><span id=\"6uri和url\">6.URI和URL</span></h3>\n<p>与URI（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。URL正是使用WEB浏览器等访问WEB页面时需要输入的网页地址。</p>\n<h4><span id=\"统一资源标识符\">统一资源标识符</span></h4>\n<p>URI是Uniform Resource Identifier 的缩写。</p>\n<blockquote>\n<p>Uniform</p>\n</blockquote>\n<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。</p>\n<blockquote>\n<p>Resource</p>\n</blockquote>\n<p>资源的定义是“可标示的任何东西”。除了文档文件、图像或服务等能够区别于其他类型的，全都可作为资源。另外，资源不仅仅可以是单一的，也可以说是多数的集合体。</p>\n<blockquote>\n<p>Identifier</p>\n</blockquote>\n<p>表示可标识的对象。也成为标识符。</p>\n<blockquote>\n<p><strong>综上所述,URI就是由某个协议方案标识的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。</strong></p>\n</blockquote>\n<p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p>\n<h4><span id=\"uri格式\">URI格式</span></h4>\n<p><img src=\"img/http-7.jpeg\" alt=\"URI格式\"></p>\n<blockquote>\n<p>登录信息</p>\n</blockquote>\n<p>指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是可选。</p>\n<blockquote>\n<p>服务器地址</p>\n</blockquote>\n<p>使用绝对URI 必须指定待访问的服务器地址。</p>\n<blockquote>\n<p>服务器端口号</p>\n</blockquote>\n<p>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</p>\n<blockquote>\n<p>带层次的文件路径</p>\n</blockquote>\n<p>指定服务器上的文件路径来定位特指的资源。</p>\n<blockquote>\n<p>查询字符串</p>\n</blockquote>\n<p>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项可选。</p>\n<blockquote>\n<p>片段标识符</p>\n</blockquote>\n<p>使用片段标识符通常可标记出已获取资源中的子资源。但在RFC中并没有明确规定其使用方法。该项可选。</p>\n<blockquote>\n<p>写在最后</p>\n</blockquote>\n<p>因为本身写博客比较少，写作能力又有点弱。又特别想把看过的东西写下来，所以这篇博客大部分都是按着原书上的字用键盘打出来的。我想也许写的多了慢慢也就会有自己的语言了吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>第一篇:了解Web及网络基础</h2>\n<hr>\n<h3>1.web是建立在何种技术之上？</h3>\n<p>当我们再网页浏览器的地址栏输入URL时，web浏览器从web服务器获取文件资源等信息，从而显示出web页面。</p>\n<p>web使用一种名为HTTP（超文本传输协议） 的协议作为规范，完成从客户端到服务端等一系列运作流程。可以说，web是建立在HTTP协议上通信的。</p>\n<h3>2.网络基础 TCP/IP</h3>\n<p>为了理解HTTP，我们有必要了解一下TCP/IP协议族。</p>\n<p>通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。</p>\n<h4><strong>2.1 TCP/IP 协议族</strong></h4>\n<p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则成为协议。</p>\n<p><img src=\"img/http-1.jpeg\" alt=\"TCP/IP\"><br>\n图：TCP/IP是互联网相关的各协议族的总称</p>\n<p>协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤等。</p>\n<p>像这样把与互联网相关联的协议集合起来总称为TCP/IP。</p>\n<h4><strong>2.2 TCP/IP 的分层管理</strong></h4>\n<p>TCP/IP 协议族里重要的一点就是分层。</p>\n<ul>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>数据链路层</li>\n</ul>\n<p><strong>TCP/IP协议族各层的作用如下：</strong></p>\n<blockquote>\n<p><strong><em>应用层：</em></strong></p>\n</blockquote>\n<p>应用层决定了向用户提供应用服务时通信的活动。<br>\nTCP/IP协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol,文件传输协议）和DNS（Domain Name System,域名系统）服务就是其中两类。</p>\n<p>HTTP 协议也处于该层</p>\n<blockquote>\n<p><strong><em>传输层：</em></strong></p>\n</blockquote>\n<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。</p>\n<p>在传输层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p>\n<blockquote>\n<p><strong><em>网络层：</em></strong></p>\n</blockquote>\n<p>网络层用来处理在网上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p>\n<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>\n<blockquote>\n<p><strong><em>链路层：（又名数据链路层，网络接口层）</em></strong></p>\n</blockquote>\n<p>用来处理链接网络的硬件部分。包括控制 操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</p>\n<h4><strong>2.3 TCP/IP通信传输流</strong></h4>\n<p><img src=\"img/http-2.jpeg\" alt=\"通信传输流\"><br>\n利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往应用层上走。</p>\n<p>接着，为了传输方便，在传输层（TCP协议）把从应用层处接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>\n<p>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。</p>\n<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。</p>\n<p><img src=\"img/http-3.jpeg\" alt=\"通信传输流包含首部信息\"></p>\n<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。</p>\n<blockquote>\n<p>这种把数据信息包装起来的做法成为封装。</p>\n</blockquote>\n<h3>3.与HTTP关系密切的协议：IP、TCP和DNS</h3>\n<h4><strong>负责传输的IP协议</strong></h4>\n<p>按层次分，IP 网际协议位于网络层。几乎所有的使用网络的系统都会用到IP协议。可能有人会把&quot;IP&quot;和&quot;IP地址&quot;搞混，&quot;IP&quot;其实是一种协议的名称。</p>\n<p>IP协议的作用是把各种数据包传输给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。</p>\n<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会改变。</p>\n<blockquote>\n<p>使用ARP协议凭借MAC地址进行通信</p>\n</blockquote>\n<p>IP间的通信依赖MAC地址。在网络上，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>\n<blockquote>\n<p>没人能全面掌握互联网中的传输状况</p>\n</blockquote>\n<p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。</p>\n<p>这种机制称为路由选择，有点像快递公司的送货过程。我们只知道具体用的什么快递，在哪中转站，倒是不知道具体走的什么路线，用的什么工具等等。</p>\n<p><img src=\"img/http-4.jpeg\" alt=\"IP传输过程\"></p>\n<h4>确保可靠性的TCP协议</h4>\n<p>按层次分，TCP位于传输层，提供可靠的字节流服务。</p>\n<p>所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。</p>\n<blockquote>\n<p>确保数据能达到目标</p>\n</blockquote>\n<p>为了准确无误地将数据传送到目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志SYN和ACK</p>\n<p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p>\n<p><img src=\"img/http-5.jpeg\" alt=\"DNS解析\"></p>\n<p>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p>\n<h3>4.负责域名解析的DNS服务</h3>\n<p>DNS 服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p>\n<p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的习惯。</p>\n<p><img src=\"img/http-6.jpeg\" alt=\"DNS解析\"></p>\n<h3>5.各种协议与HTTP协议的关系</h3>\n<p>我们可以通过这张图来了解下IP协议、TCP协议、和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用</p>\n<p><img src=\"img/http-8.jpeg\" alt=\"各种协议的关系\"></p>\n<h3>6.URI和URL</h3>\n<p>与URI（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。URL正是使用WEB浏览器等访问WEB页面时需要输入的网页地址。</p>\n<h4>统一资源标识符</h4>\n<p>URI是Uniform Resource Identifier 的缩写。</p>\n<blockquote>\n<p>Uniform</p>\n</blockquote>\n<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。</p>\n<blockquote>\n<p>Resource</p>\n</blockquote>\n<p>资源的定义是“可标示的任何东西”。除了文档文件、图像或服务等能够区别于其他类型的，全都可作为资源。另外，资源不仅仅可以是单一的，也可以说是多数的集合体。</p>\n<blockquote>\n<p>Identifier</p>\n</blockquote>\n<p>表示可标识的对象。也成为标识符。</p>\n<blockquote>\n<p><strong>综上所述,URI就是由某个协议方案标识的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。</strong></p>\n</blockquote>\n<p>URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。</p>\n<h4>URI格式</h4>\n<p><img src=\"img/http-7.jpeg\" alt=\"URI格式\"></p>\n<blockquote>\n<p>登录信息</p>\n</blockquote>\n<p>指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是可选。</p>\n<blockquote>\n<p>服务器地址</p>\n</blockquote>\n<p>使用绝对URI 必须指定待访问的服务器地址。</p>\n<blockquote>\n<p>服务器端口号</p>\n</blockquote>\n<p>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</p>\n<blockquote>\n<p>带层次的文件路径</p>\n</blockquote>\n<p>指定服务器上的文件路径来定位特指的资源。</p>\n<blockquote>\n<p>查询字符串</p>\n</blockquote>\n<p>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项可选。</p>\n<blockquote>\n<p>片段标识符</p>\n</blockquote>\n<p>使用片段标识符通常可标记出已获取资源中的子资源。但在RFC中并没有明确规定其使用方法。该项可选。</p>\n<blockquote>\n<p>写在最后</p>\n</blockquote>\n<p>因为本身写博客比较少，写作能力又有点弱。又特别想把看过的东西写下来，所以这篇博客大部分都是按着原书上的字用键盘打出来的。我想也许写的多了慢慢也就会有自己的语言了吧。</p>\n"},{"title":"第三章：HTTP报文内的HTTP信息","catalog":true,"date":"2019-01-16T05:42:20.000Z","subtitle":"HTTP报文内的HTTP信息","header-img":null,"catagories":["HTTP"],"_content":"\n# HTTP报文内的HTTP信息\n\n## 1.HTTP 报文\n\n用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的报文叫响应报文。\n\nHTTP报文是由多行（用CR+LF作换行符）数据构成的字符串文本。\n\nHTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。\n\n![报文结构](img/1.jpeg)\n\n## 2.请求报文和响应报文的结构\n\n请求报文和响应报文的结构\n\n![](img/2.jpeg)\n\n请求报文和响应报文的实例\n\n![](img/3.jpeg)\n\n> 请求报文和响应报文的首部内容由一下内容组成：\n\n- 请求行 （包含用于请求的方法，请求URI和HTTP版本）\n- 状态行 （包含表明响应结果的状态码、原因短语和HTTP版本）\n- 首部字段 （包含标识请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部）\n- 其他 （可能包含HTTP的RFC里未定义的首部（cookie等））\n\n\n## 3.编码提升传输速率\n\nHTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。在传输时编码，能有效地处理大量的访问请求。但是编码的操作需要计算机完成，因此会消耗更多的CPU资源。\n\n### 3.1报文主体和实体主体的差异\n\n> 报文（message）\n\n是HTTP通信中的基本单位，由8位组字节流（octetsequence，其中ocet为8个比特）组成，通过HTTP通信传输。\n\n> 实体（entity）\n\n作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。\n\nHTTP报文的主体用于传输请求或响应的实体主体\n\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n\n### 3.2压缩传输的内容编码\n\n向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。\n\n内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。\n\n![内容编码](img/4.jpeg)\n\n常用的内容编码有以下几种\n\n- gzip (GNU zip)\n- compress (UNIX 系统的标准压缩)\n- deflate (zlib)\n- identity (不进行编码)\n\n### 3.分割发送的分开传输编码\n\n在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。\n\n这种把实体主体分块的功能称为分块传输编码\n\n![分块传输](img/5.jpeg)\n\n分块传输编码会将实体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）来标记”\n\n使用分块传输编码的实体主体会由接受的客户端负责解码，恢复到编码的实体主体。\n\n## 4.发送多种数据的多部分对象集合\n\n发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME 来描述标记数据类型。而在MIME扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同类型的数据。\n\n相应地，HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。\n\n多部分对象集合包含的对象如下：\n\n- multipart/form-data\n\n    在Web 表单文件上传时使用\n    \n    ```\n    “Content-Type: multipart/form-data; boundary=AaB03x\n    --AaB03x\n    Content-Disposition: form-data; name=\"field1\"\n    Joe Blow\n    --AaB03x\n    Content-Disposition: form-data; name=\"pics\"; filename=\"file1.txt\"\n    Content-Type: text/plain\n    ...（file1.txt的数据）...\n    --AaB03x--”\n    ```\n\n- multipart/byteranges\n\n    状态码206 （部分内容）响应报文包含了多个范围的内容时使用\n    \n    ```\n    “HTTP/1.1 206 Partial Content\n    Date: Fri, 13 Jul 2012 02:45:26 GMT\n    Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT\n    Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n    --THIS_STRING_SEPARATES\n    Content-Type: application/pdf\n    Content-Range: bytes 500-999/8000\n    ...（范围指定的数据）...\n    --THIS_STRING_SEPARATES\n    Content-Type: application/pdf\n    Content-Range: bytes 7000-7999/8000\n    ...（范围指定的数据）...\n    --THIS_STRING_SEPARATES--”\n    ```\n\n在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。\n\n使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“--”标记（例如：--AaB03x、--THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“--”标记（例如：--AaB03x--、--THIS_STRING_SEPARATES--）作为结束。\n\n## 5.获取部分内容的范围请求\n\n以前，用户没有现在这种高速的宽度访问互联网呢，当时下载一个很大的文件或者图片非常吃力。如果下载过程中遇到中断，就得重新下载。为了解决上述问题，需要一种回复的机制。所谓恢复是指能从之前下载中断处恢复下载。\n\n要实现该功能需要指定下载的实体范围。像这样，制定范围发送的请求叫做范围请求。\n\n对一份10000字节大小的资源，如果使用范围请求，可以只请求5001-10000字节内的资源\n\n![范围请求](img/6.jpeg)\n\n执行范围请求时，会用到首部字段Range 来指定资源的byte范围。\n\nbyte 范围的指定形式如下：\n\n- 5001-10000 字节\n\n```\nRange:bytes=5001-10000\n```\n\n- 从5001字节之后全部的\n\n```\nRange:bytes=5001-\n```\n\n- 从一开始到3000字节和5000-7000字节的多重范围\n\n```\nRange:bytes=3000,5000-7000\n```\n针对范围请求，响应会返回状态码为206的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type 表明multipart/byteranges 后返回响应报文\n\n如果服务器端无法响应范围请求，则会返回状态码200 OK 和完整的实体内容\n\n## 6.内容协商返回合适的内容\n\n同一个WEB 网站有可能存在着多份相同内容的页面。比如英语版和中文版的web页面。他们内容上虽然相同，但使用的语言却不同。\n\n当浏览器的默认语言为英语或中文，访问相同URI的Web 页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商。\n\n内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。\n\n包含在请求报文中的某些首部字段就是判断的基准\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Content-Language\n\n内容协商技术有以下3种类型\n\n**服务器驱动协商**\n\n由服务器端进行内容协商。以请求的首部字段为参考，在服务端自动处理。\n\n**客户端驱动协商**\n\n由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择\n\n**透明协商**\n\n是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种做法","source":"_posts/HTTP-3.md","raw":"---\ntitle: 第三章：HTTP报文内的HTTP信息\ncatalog: true\ndate: 2019-01-16 13:42:20\nsubtitle: HTTP报文内的HTTP信息\nheader-img:\ntags: \n- 图解HTTP\ncatagories:\n- HTTP\n---\n\n# HTTP报文内的HTTP信息\n\n## 1.HTTP 报文\n\n用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的报文叫响应报文。\n\nHTTP报文是由多行（用CR+LF作换行符）数据构成的字符串文本。\n\nHTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。\n\n![报文结构](img/1.jpeg)\n\n## 2.请求报文和响应报文的结构\n\n请求报文和响应报文的结构\n\n![](img/2.jpeg)\n\n请求报文和响应报文的实例\n\n![](img/3.jpeg)\n\n> 请求报文和响应报文的首部内容由一下内容组成：\n\n- 请求行 （包含用于请求的方法，请求URI和HTTP版本）\n- 状态行 （包含表明响应结果的状态码、原因短语和HTTP版本）\n- 首部字段 （包含标识请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部）\n- 其他 （可能包含HTTP的RFC里未定义的首部（cookie等））\n\n\n## 3.编码提升传输速率\n\nHTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。在传输时编码，能有效地处理大量的访问请求。但是编码的操作需要计算机完成，因此会消耗更多的CPU资源。\n\n### 3.1报文主体和实体主体的差异\n\n> 报文（message）\n\n是HTTP通信中的基本单位，由8位组字节流（octetsequence，其中ocet为8个比特）组成，通过HTTP通信传输。\n\n> 实体（entity）\n\n作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。\n\nHTTP报文的主体用于传输请求或响应的实体主体\n\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n\n### 3.2压缩传输的内容编码\n\n向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。\n\n内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。\n\n![内容编码](img/4.jpeg)\n\n常用的内容编码有以下几种\n\n- gzip (GNU zip)\n- compress (UNIX 系统的标准压缩)\n- deflate (zlib)\n- identity (不进行编码)\n\n### 3.分割发送的分开传输编码\n\n在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。\n\n这种把实体主体分块的功能称为分块传输编码\n\n![分块传输](img/5.jpeg)\n\n分块传输编码会将实体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）来标记”\n\n使用分块传输编码的实体主体会由接受的客户端负责解码，恢复到编码的实体主体。\n\n## 4.发送多种数据的多部分对象集合\n\n发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME 来描述标记数据类型。而在MIME扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同类型的数据。\n\n相应地，HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。\n\n多部分对象集合包含的对象如下：\n\n- multipart/form-data\n\n    在Web 表单文件上传时使用\n    \n    ```\n    “Content-Type: multipart/form-data; boundary=AaB03x\n    --AaB03x\n    Content-Disposition: form-data; name=\"field1\"\n    Joe Blow\n    --AaB03x\n    Content-Disposition: form-data; name=\"pics\"; filename=\"file1.txt\"\n    Content-Type: text/plain\n    ...（file1.txt的数据）...\n    --AaB03x--”\n    ```\n\n- multipart/byteranges\n\n    状态码206 （部分内容）响应报文包含了多个范围的内容时使用\n    \n    ```\n    “HTTP/1.1 206 Partial Content\n    Date: Fri, 13 Jul 2012 02:45:26 GMT\n    Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT\n    Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n    --THIS_STRING_SEPARATES\n    Content-Type: application/pdf\n    Content-Range: bytes 500-999/8000\n    ...（范围指定的数据）...\n    --THIS_STRING_SEPARATES\n    Content-Type: application/pdf\n    Content-Range: bytes 7000-7999/8000\n    ...（范围指定的数据）...\n    --THIS_STRING_SEPARATES--”\n    ```\n\n在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。\n\n使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“--”标记（例如：--AaB03x、--THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“--”标记（例如：--AaB03x--、--THIS_STRING_SEPARATES--）作为结束。\n\n## 5.获取部分内容的范围请求\n\n以前，用户没有现在这种高速的宽度访问互联网呢，当时下载一个很大的文件或者图片非常吃力。如果下载过程中遇到中断，就得重新下载。为了解决上述问题，需要一种回复的机制。所谓恢复是指能从之前下载中断处恢复下载。\n\n要实现该功能需要指定下载的实体范围。像这样，制定范围发送的请求叫做范围请求。\n\n对一份10000字节大小的资源，如果使用范围请求，可以只请求5001-10000字节内的资源\n\n![范围请求](img/6.jpeg)\n\n执行范围请求时，会用到首部字段Range 来指定资源的byte范围。\n\nbyte 范围的指定形式如下：\n\n- 5001-10000 字节\n\n```\nRange:bytes=5001-10000\n```\n\n- 从5001字节之后全部的\n\n```\nRange:bytes=5001-\n```\n\n- 从一开始到3000字节和5000-7000字节的多重范围\n\n```\nRange:bytes=3000,5000-7000\n```\n针对范围请求，响应会返回状态码为206的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type 表明multipart/byteranges 后返回响应报文\n\n如果服务器端无法响应范围请求，则会返回状态码200 OK 和完整的实体内容\n\n## 6.内容协商返回合适的内容\n\n同一个WEB 网站有可能存在着多份相同内容的页面。比如英语版和中文版的web页面。他们内容上虽然相同，但使用的语言却不同。\n\n当浏览器的默认语言为英语或中文，访问相同URI的Web 页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商。\n\n内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。\n\n包含在请求报文中的某些首部字段就是判断的基准\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Content-Language\n\n内容协商技术有以下3种类型\n\n**服务器驱动协商**\n\n由服务器端进行内容协商。以请求的首部字段为参考，在服务端自动处理。\n\n**客户端驱动协商**\n\n由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择\n\n**透明协商**\n\n是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种做法","slug":"HTTP-3","published":1,"updated":"2019-01-16T05:55:30.219Z","_id":"cjqyrrxdz0003czhqx9u1h4my","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"http报文内的http信息\">HTTP报文内的HTTP信息</span></h1>\n<h2><span id=\"1http-报文\">1.HTTP 报文</span></h2>\n<p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的报文叫响应报文。</p>\n<p>HTTP报文是由多行（用CR+LF作换行符）数据构成的字符串文本。</p>\n<p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</p>\n<p><img src=\"img/1.jpeg\" alt=\"报文结构\"></p>\n<h2><span id=\"2请求报文和响应报文的结构\">2.请求报文和响应报文的结构</span></h2>\n<p>请求报文和响应报文的结构</p>\n<p><img src=\"img/2.jpeg\" alt=\"\"></p>\n<p>请求报文和响应报文的实例</p>\n<p><img src=\"img/3.jpeg\" alt=\"\"></p>\n<blockquote>\n<p>请求报文和响应报文的首部内容由一下内容组成：</p>\n</blockquote>\n<ul>\n<li>请求行 （包含用于请求的方法，请求URI和HTTP版本）</li>\n<li>状态行 （包含表明响应结果的状态码、原因短语和HTTP版本）</li>\n<li>首部字段 （包含标识请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部）</li>\n<li>其他 （可能包含HTTP的RFC里未定义的首部（cookie等））</li>\n</ul>\n<h2><span id=\"3编码提升传输速率\">3.编码提升传输速率</span></h2>\n<p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。在传输时编码，能有效地处理大量的访问请求。但是编码的操作需要计算机完成，因此会消耗更多的CPU资源。</p>\n<h3><span id=\"31报文主体和实体主体的差异\">3.1报文主体和实体主体的差异</span></h3>\n<blockquote>\n<p>报文（message）</p>\n</blockquote>\n<p>是HTTP通信中的基本单位，由8位组字节流（octetsequence，其中ocet为8个比特）组成，通过HTTP通信传输。</p>\n<blockquote>\n<p>实体（entity）</p>\n</blockquote>\n<p>作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。</p>\n<p>HTTP报文的主体用于传输请求或响应的实体主体</p>\n<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>\n<h3><span id=\"32压缩传输的内容编码\">3.2压缩传输的内容编码</span></h3>\n<p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。</p>\n<p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。</p>\n<p><img src=\"img/4.jpeg\" alt=\"内容编码\"></p>\n<p>常用的内容编码有以下几种</p>\n<ul>\n<li>gzip (GNU zip)</li>\n<li>compress (UNIX 系统的标准压缩)</li>\n<li>deflate (zlib)</li>\n<li>identity (不进行编码)</li>\n</ul>\n<h3><span id=\"3分割发送的分开传输编码\">3.分割发送的分开传输编码</span></h3>\n<p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p>\n<p>这种把实体主体分块的功能称为分块传输编码</p>\n<p><img src=\"img/5.jpeg\" alt=\"分块传输\"></p>\n<p>分块传输编码会将实体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）来标记”</p>\n<p>使用分块传输编码的实体主体会由接受的客户端负责解码，恢复到编码的实体主体。</p>\n<h2><span id=\"4发送多种数据的多部分对象集合\">4.发送多种数据的多部分对象集合</span></h2>\n<p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME 来描述标记数据类型。而在MIME扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同类型的数据。</p>\n<p>相应地，HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p>\n<p>多部分对象集合包含的对象如下：</p>\n<ul>\n<li>\n<p>multipart/form-data</p>\n<p>在Web 表单文件上传时使用</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“Content-Type: multipart/form-data; <span class=\"attribute\">boundary</span>=AaB03x</span><br><span class=\"line\">--AaB03x</span><br><span class=\"line\">Content-Disposition: form-data; <span class=\"attribute\">name</span>=<span class=\"string\">\"field1\"</span></span><br><span class=\"line\">Joe Blow</span><br><span class=\"line\">--AaB03x</span><br><span class=\"line\">Content-Disposition: form-data; <span class=\"attribute\">name</span>=<span class=\"string\">\"pics\"</span>; <span class=\"attribute\">filename</span>=<span class=\"string\">\"file1.txt\"</span></span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"><span class=\"built_in\">..</span>.（file1.txt的数据）<span class=\"built_in\">..</span>.</span><br><span class=\"line\">--AaB03x--”</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>multipart/byteranges</p>\n<p>状态码206 （部分内容）响应报文包含了多个范围的内容时使用</p>\n  <figure class=\"highlight ldif\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“HTTP/1.1 206 Partial Content</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Fri, 13 Jul 2012 02:45:26 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: multipart/byteranges; boundary=THIS_STRING_SEPARATES</span><br><span class=\"line\"><span class=\"literal\">--THIS_STRING_SEPARATES</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: application/pdf</span><br><span class=\"line\"><span class=\"attribute\">Content-Range</span>: bytes 500-999/8000</span><br><span class=\"line\">...（范围指定的数据）...</span><br><span class=\"line\"><span class=\"literal\">--THIS_STRING_SEPARATES</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: application/pdf</span><br><span class=\"line\"><span class=\"attribute\">Content-Range</span>: bytes 7000-7999/8000</span><br><span class=\"line\">...（范围指定的数据）...</span><br><span class=\"line\"><span class=\"literal\">--THIS_STRING_SEPARATES--”</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p>\n<p>使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、--THIS_STRING_SEPARATES–）作为结束。</p>\n<h2><span id=\"5获取部分内容的范围请求\">5.获取部分内容的范围请求</span></h2>\n<p>以前，用户没有现在这种高速的宽度访问互联网呢，当时下载一个很大的文件或者图片非常吃力。如果下载过程中遇到中断，就得重新下载。为了解决上述问题，需要一种回复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p>\n<p>要实现该功能需要指定下载的实体范围。像这样，制定范围发送的请求叫做范围请求。</p>\n<p>对一份10000字节大小的资源，如果使用范围请求，可以只请求5001-10000字节内的资源</p>\n<p><img src=\"img/6.jpeg\" alt=\"范围请求\"></p>\n<p>执行范围请求时，会用到首部字段Range 来指定资源的byte范围。</p>\n<p>byte 范围的指定形式如下：</p>\n<ul>\n<li>5001-10000 字节</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Range:<span class=\"attribute\">bytes</span>=5001-10000</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从5001字节之后全部的</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Range:<span class=\"attribute\">bytes</span>=5001-</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从一开始到3000字节和5000-7000字节的多重范围</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Range:<span class=\"attribute\">bytes</span>=3000,5000-7000</span><br></pre></td></tr></table></figure>\n<p>针对范围请求，响应会返回状态码为206的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type 表明multipart/byteranges 后返回响应报文</p>\n<p>如果服务器端无法响应范围请求，则会返回状态码200 OK 和完整的实体内容</p>\n<h2><span id=\"6内容协商返回合适的内容\">6.内容协商返回合适的内容</span></h2>\n<p>同一个WEB 网站有可能存在着多份相同内容的页面。比如英语版和中文版的web页面。他们内容上虽然相同，但使用的语言却不同。</p>\n<p>当浏览器的默认语言为英语或中文，访问相同URI的Web 页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商。</p>\n<p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>\n<p>包含在请求报文中的某些首部字段就是判断的基准</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n<p>内容协商技术有以下3种类型</p>\n<p><strong>服务器驱动协商</strong></p>\n<p>由服务器端进行内容协商。以请求的首部字段为参考，在服务端自动处理。</p>\n<p><strong>客户端驱动协商</strong></p>\n<p>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择</p>\n<p><strong>透明协商</strong></p>\n<p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种做法</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>HTTP报文内的HTTP信息</h1>\n<h2>1.HTTP 报文</h2>\n<p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的报文叫响应报文。</p>\n<p>HTTP报文是由多行（用CR+LF作换行符）数据构成的字符串文本。</p>\n<p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</p>\n<p><img src=\"img/1.jpeg\" alt=\"报文结构\"></p>\n<h2>2.请求报文和响应报文的结构</h2>\n<p>请求报文和响应报文的结构</p>\n<p><img src=\"img/2.jpeg\" alt=\"\"></p>\n<p>请求报文和响应报文的实例</p>\n<p><img src=\"img/3.jpeg\" alt=\"\"></p>\n<blockquote>\n<p>请求报文和响应报文的首部内容由一下内容组成：</p>\n</blockquote>\n<ul>\n<li>请求行 （包含用于请求的方法，请求URI和HTTP版本）</li>\n<li>状态行 （包含表明响应结果的状态码、原因短语和HTTP版本）</li>\n<li>首部字段 （包含标识请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部）</li>\n<li>其他 （可能包含HTTP的RFC里未定义的首部（cookie等））</li>\n</ul>\n<h2>3.编码提升传输速率</h2>\n<p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。在传输时编码，能有效地处理大量的访问请求。但是编码的操作需要计算机完成，因此会消耗更多的CPU资源。</p>\n<h3>3.1报文主体和实体主体的差异</h3>\n<blockquote>\n<p>报文（message）</p>\n</blockquote>\n<p>是HTTP通信中的基本单位，由8位组字节流（octetsequence，其中ocet为8个比特）组成，通过HTTP通信传输。</p>\n<blockquote>\n<p>实体（entity）</p>\n</blockquote>\n<p>作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。</p>\n<p>HTTP报文的主体用于传输请求或响应的实体主体</p>\n<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>\n<h3>3.2压缩传输的内容编码</h3>\n<p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。</p>\n<p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接受并负责解码。</p>\n<p><img src=\"img/4.jpeg\" alt=\"内容编码\"></p>\n<p>常用的内容编码有以下几种</p>\n<ul>\n<li>gzip (GNU zip)</li>\n<li>compress (UNIX 系统的标准压缩)</li>\n<li>deflate (zlib)</li>\n<li>identity (不进行编码)</li>\n</ul>\n<h3>3.分割发送的分开传输编码</h3>\n<p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p>\n<p>这种把实体主体分块的功能称为分块传输编码</p>\n<p><img src=\"img/5.jpeg\" alt=\"分块传输\"></p>\n<p>分块传输编码会将实体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）来标记”</p>\n<p>使用分块传输编码的实体主体会由接受的客户端负责解码，恢复到编码的实体主体。</p>\n<h2>4.发送多种数据的多部分对象集合</h2>\n<p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME 来描述标记数据类型。而在MIME扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同类型的数据。</p>\n<p>相应地，HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p>\n<p>多部分对象集合包含的对象如下：</p>\n<ul>\n<li>\n<p>multipart/form-data</p>\n<p>在Web 表单文件上传时使用</p>\n  <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“Content-Type: multipart/form-data; <span class=\"attribute\">boundary</span>=AaB03x</span><br><span class=\"line\">--AaB03x</span><br><span class=\"line\">Content-Disposition: form-data; <span class=\"attribute\">name</span>=<span class=\"string\">\"field1\"</span></span><br><span class=\"line\">Joe Blow</span><br><span class=\"line\">--AaB03x</span><br><span class=\"line\">Content-Disposition: form-data; <span class=\"attribute\">name</span>=<span class=\"string\">\"pics\"</span>; <span class=\"attribute\">filename</span>=<span class=\"string\">\"file1.txt\"</span></span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"><span class=\"built_in\">..</span>.（file1.txt的数据）<span class=\"built_in\">..</span>.</span><br><span class=\"line\">--AaB03x--”</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>multipart/byteranges</p>\n<p>状态码206 （部分内容）响应报文包含了多个范围的内容时使用</p>\n  <figure class=\"highlight ldif\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“HTTP/1.1 206 Partial Content</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Fri, 13 Jul 2012 02:45:26 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: multipart/byteranges; boundary=THIS_STRING_SEPARATES</span><br><span class=\"line\"><span class=\"literal\">--THIS_STRING_SEPARATES</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: application/pdf</span><br><span class=\"line\"><span class=\"attribute\">Content-Range</span>: bytes 500-999/8000</span><br><span class=\"line\">...（范围指定的数据）...</span><br><span class=\"line\"><span class=\"literal\">--THIS_STRING_SEPARATES</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: application/pdf</span><br><span class=\"line\"><span class=\"attribute\">Content-Range</span>: bytes 7000-7999/8000</span><br><span class=\"line\">...（范围指定的数据）...</span><br><span class=\"line\"><span class=\"literal\">--THIS_STRING_SEPARATES--”</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p>\n<p>使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、--THIS_STRING_SEPARATES–）作为结束。</p>\n<h2>5.获取部分内容的范围请求</h2>\n<p>以前，用户没有现在这种高速的宽度访问互联网呢，当时下载一个很大的文件或者图片非常吃力。如果下载过程中遇到中断，就得重新下载。为了解决上述问题，需要一种回复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p>\n<p>要实现该功能需要指定下载的实体范围。像这样，制定范围发送的请求叫做范围请求。</p>\n<p>对一份10000字节大小的资源，如果使用范围请求，可以只请求5001-10000字节内的资源</p>\n<p><img src=\"img/6.jpeg\" alt=\"范围请求\"></p>\n<p>执行范围请求时，会用到首部字段Range 来指定资源的byte范围。</p>\n<p>byte 范围的指定形式如下：</p>\n<ul>\n<li>5001-10000 字节</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Range:<span class=\"attribute\">bytes</span>=5001-10000</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从5001字节之后全部的</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Range:<span class=\"attribute\">bytes</span>=5001-</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从一开始到3000字节和5000-7000字节的多重范围</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Range:<span class=\"attribute\">bytes</span>=3000,5000-7000</span><br></pre></td></tr></table></figure>\n<p>针对范围请求，响应会返回状态码为206的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type 表明multipart/byteranges 后返回响应报文</p>\n<p>如果服务器端无法响应范围请求，则会返回状态码200 OK 和完整的实体内容</p>\n<h2>6.内容协商返回合适的内容</h2>\n<p>同一个WEB 网站有可能存在着多份相同内容的页面。比如英语版和中文版的web页面。他们内容上虽然相同，但使用的语言却不同。</p>\n<p>当浏览器的默认语言为英语或中文，访问相同URI的Web 页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商。</p>\n<p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>\n<p>包含在请求报文中的某些首部字段就是判断的基准</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n<p>内容协商技术有以下3种类型</p>\n<p><strong>服务器驱动协商</strong></p>\n<p>由服务器端进行内容协商。以请求的首部字段为参考，在服务端自动处理。</p>\n<p><strong>客户端驱动协商</strong></p>\n<p>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择</p>\n<p><strong>透明协商</strong></p>\n<p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种做法</p>\n"},{"title":"Future","catalog":true,"date":"2019-01-09T02:35:39.000Z","subtitle":null,"header-img":"img/header_img/heye.jpg","catagories":["FG"],"_content":"### 决胜未来，2019年前端技术学习\n>第一需要学习的技术：基础知识\n\n作为一个前端HTML+CSS+JavaScrip已经是不可逃避的了，但我觉得这还不够，现在前端都在向大前端方向发展，服务端基础知识、计算机基础知识等都是需要基础知识做铺垫的。\n>第二需要学习的技术：框架\n\nReact、Vue、Angular等相关技术栈精通一个我觉得就够了，但是这里所说的精通不仅仅是会用，因为仅仅会用也是根据你的项目会用而已。还要学习其原理，和一些不经常使用却很有用的知识点。\n>第三需要学习的技术：node.js或者说任意一门服务端语言\n\n作为一个前端如果仅仅关注前端这点知识是不够的，学习一门服务器语言更能理解一个项目的技术架构，对于的项目优化有一个更深层次的认识。\n\n>第四需要学习的技术：PWA\n\n>第五需要学习的技术：WebGL\n\n目前能想到是以上的技术，后续想到再更新吧。在这里给自己定个目标有个大体的技术方向。","source":"_posts/future.md","raw":"---\ntitle: Future\ncatalog: true\ndate: 2019-01-09 10:35:39\nsubtitle:\nheader-img: \"img/header_img/heye.jpg\"\ntags:\n- 前端\ncatagories:\n- FG\n---\n### 决胜未来，2019年前端技术学习\n>第一需要学习的技术：基础知识\n\n作为一个前端HTML+CSS+JavaScrip已经是不可逃避的了，但我觉得这还不够，现在前端都在向大前端方向发展，服务端基础知识、计算机基础知识等都是需要基础知识做铺垫的。\n>第二需要学习的技术：框架\n\nReact、Vue、Angular等相关技术栈精通一个我觉得就够了，但是这里所说的精通不仅仅是会用，因为仅仅会用也是根据你的项目会用而已。还要学习其原理，和一些不经常使用却很有用的知识点。\n>第三需要学习的技术：node.js或者说任意一门服务端语言\n\n作为一个前端如果仅仅关注前端这点知识是不够的，学习一门服务器语言更能理解一个项目的技术架构，对于的项目优化有一个更深层次的认识。\n\n>第四需要学习的技术：PWA\n\n>第五需要学习的技术：WebGL\n\n目前能想到是以上的技术，后续想到再更新吧。在这里给自己定个目标有个大体的技术方向。","slug":"future","published":1,"updated":"2019-01-09T03:18:26.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqyrrxe50006czhqvwwpfh6t","content":"<h3><span id=\"决胜未来2019年前端技术学习\">决胜未来，2019年前端技术学习</span></h3>\n<blockquote>\n<p>第一需要学习的技术：基础知识</p>\n</blockquote>\n<p>作为一个前端HTML+CSS+JavaScrip已经是不可逃避的了，但我觉得这还不够，现在前端都在向大前端方向发展，服务端基础知识、计算机基础知识等都是需要基础知识做铺垫的。</p>\n<blockquote>\n<p>第二需要学习的技术：框架</p>\n</blockquote>\n<p>React、Vue、Angular等相关技术栈精通一个我觉得就够了，但是这里所说的精通不仅仅是会用，因为仅仅会用也是根据你的项目会用而已。还要学习其原理，和一些不经常使用却很有用的知识点。</p>\n<blockquote>\n<p>第三需要学习的技术：node.js或者说任意一门服务端语言</p>\n</blockquote>\n<p>作为一个前端如果仅仅关注前端这点知识是不够的，学习一门服务器语言更能理解一个项目的技术架构，对于的项目优化有一个更深层次的认识。</p>\n<blockquote>\n<p>第四需要学习的技术：PWA</p>\n</blockquote>\n<blockquote>\n<p>第五需要学习的技术：WebGL</p>\n</blockquote>\n<p>目前能想到是以上的技术，后续想到再更新吧。在这里给自己定个目标有个大体的技术方向。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>决胜未来，2019年前端技术学习</h3>\n<blockquote>\n<p>第一需要学习的技术：基础知识</p>\n</blockquote>\n<p>作为一个前端HTML+CSS+JavaScrip已经是不可逃避的了，但我觉得这还不够，现在前端都在向大前端方向发展，服务端基础知识、计算机基础知识等都是需要基础知识做铺垫的。</p>\n<blockquote>\n<p>第二需要学习的技术：框架</p>\n</blockquote>\n<p>React、Vue、Angular等相关技术栈精通一个我觉得就够了，但是这里所说的精通不仅仅是会用，因为仅仅会用也是根据你的项目会用而已。还要学习其原理，和一些不经常使用却很有用的知识点。</p>\n<blockquote>\n<p>第三需要学习的技术：node.js或者说任意一门服务端语言</p>\n</blockquote>\n<p>作为一个前端如果仅仅关注前端这点知识是不够的，学习一门服务器语言更能理解一个项目的技术架构，对于的项目优化有一个更深层次的认识。</p>\n<blockquote>\n<p>第四需要学习的技术：PWA</p>\n</blockquote>\n<blockquote>\n<p>第五需要学习的技术：WebGL</p>\n</blockquote>\n<p>目前能想到是以上的技术，后续想到再更新吧。在这里给自己定个目标有个大体的技术方向。</p>\n"},{"title":"博客简介","catalog":true,"date":"2018-08-30T08:44:31.000Z","subtitle":"关于本博客的一些记录","header-img":"img/header_img/heye.jpg","catagories":["Hexo"],"_content":"## 关于博客\n\n> 无题\n\n搭建本博客之前也前前后后用各种方式[jekyll,博客园,用vue开发]，因各种原因最终决定使用hexo框架搭建，作为自己最终的博客，希望自己可以坚持下来。\n\n> 博客搭建环境\n- 使用hexo 博客框架搭建\n- 主题来自 [YuHsuan](http://beantech.org) ,根据原主题做了一些针对个人的调整\n- 本博客部署在nginx服务器上\n- 使用 Git 管理发布到线上","source":"_posts/first-blog.md","raw":"---\ntitle: \"博客简介\"\ncatalog: true\ndate: 2018-08-30 16:44:31\nsubtitle: \"关于本博客的一些记录\"\nheader-img: \"img/header_img/heye.jpg\"\ntags:\n- Hexo\ncatagories:\n- Hexo\n---\n## 关于博客\n\n> 无题\n\n搭建本博客之前也前前后后用各种方式[jekyll,博客园,用vue开发]，因各种原因最终决定使用hexo框架搭建，作为自己最终的博客，希望自己可以坚持下来。\n\n> 博客搭建环境\n- 使用hexo 博客框架搭建\n- 主题来自 [YuHsuan](http://beantech.org) ,根据原主题做了一些针对个人的调整\n- 本博客部署在nginx服务器上\n- 使用 Git 管理发布到线上","slug":"first-blog","published":1,"updated":"2018-12-28T02:10:27.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqyrrxe80008czhqcap4twcy","content":"<h2><span id=\"关于博客\">关于博客</span></h2>\n<blockquote>\n<p>无题</p>\n</blockquote>\n<p>搭建本博客之前也前前后后用各种方式[jekyll,博客园,用vue开发]，因各种原因最终决定使用hexo框架搭建，作为自己最终的博客，希望自己可以坚持下来。</p>\n<blockquote>\n<p>博客搭建环境</p>\n</blockquote>\n<ul>\n<li>使用hexo 博客框架搭建</li>\n<li>主题来自 <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> ,根据原主题做了一些针对个人的调整</li>\n<li>本博客部署在nginx服务器上</li>\n<li>使用 Git 管理发布到线上</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>关于博客</h2>\n<blockquote>\n<p>无题</p>\n</blockquote>\n<p>搭建本博客之前也前前后后用各种方式[jekyll,博客园,用vue开发]，因各种原因最终决定使用hexo框架搭建，作为自己最终的博客，希望自己可以坚持下来。</p>\n<blockquote>\n<p>博客搭建环境</p>\n</blockquote>\n<ul>\n<li>使用hexo 博客框架搭建</li>\n<li>主题来自 <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> ,根据原主题做了一些针对个人的调整</li>\n<li>本博客部署在nginx服务器上</li>\n<li>使用 Git 管理发布到线上</li>\n</ul>\n"},{"title":"《图解HTTP》学习笔记 之 第二章：简单的HTTP协议","catalog":true,"date":"2019-01-15T02:21:40.000Z","subtitle":"简单的HTTP协议","header-img":"img/header_img/tf-logo-dark.png","catagories":["HTTP"],"_content":"\n# 第二章：简单的HTTP协议\n> 本章主要对HTTP协议结构进行讲解，主要使用HTTP/1.1\n\n## 1.HTTP协议用于客户端和服务端之间的通信\n\nHTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。\n\n请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。\n\n在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。\n\n## 2.通过请求和响应的交换达成通信\n\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。\n\n\n请求是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。\n\n![请求报文](img/1.jpeg)\n\n图：请求报文的组成\n\n响应报文基本上由协议版本、状态码（标识请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。\n\n![响应报文](img/2.jpeg)\n\n图：响应报文的组成\n\n## 3.HTTP是不保存状态的协议\n\nHTTP是一种不保存的状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。\n\n每当有新的请求时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。\n\nHTTP 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie 技术。\n\n## 4.请求URI定位资源\n\nHTTP协议使用URI定位互联网上的资源，正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。\n\n当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URL包含在内。\n\n除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI，\n\n\n## 5.请求URI定位资源\n\n### GET:获取资源\n\nGET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的是文本，那就保持原样返回；如果是像CGI那样的程序，则返回经过执行后的输出结果。\n\n### POST：传输实体主体\n\nPOST方法用来传输实体的主体\n\n虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输。虽然POST 的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。\n\n### PUT：传输文件\n\nPUT方法用来传输文件。就像FTP协议的文件上传一样，要求再请求报文的主体中包含文件的内容，然后保存到请求URI指定的位置。\n\n> 缺点：但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，一次一般的Web网站不使用该方法。\n\n### HEAD：获取报文首部\n\nHEAD 方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。\n\n### DELETE：删除文件\n\nDELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。\n\n> 缺点：但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般WEB网站也不使用DELETE方法。\n\n### OPTIONS:询问支持的方法。\n\nOPTIONS 方法用来查询针对请求URI指定的资源支持的方法。\n\n### TRACE：追踪路径\n\nTRACE 方法是让Web服务器将之前的请求通信环回给客户端的方法。\n\n发送请求时，在Max-Forwards 首部字段中填入数值，每经过一个服务器就将该数字减1，当数值刚发哦减到0时，就停止继续传输，最后接受到请求的服务器端则返回状态码 200 OK的响应\n\n客户端通过TRACE 方法可以查询发出的请求是怎么样被加工修改/篡改的。这是因为，请求想要连接到原目标服务器可能会通过代理中转，TRACE就是用来确认连接过程中发生的一系列操作。\n\n但是，TRACE方法本来就不常用，再加上它容易引发XST攻击，通常不会用到。\n\n### CONNECT：要求用隧道协议连接代理\n\nCONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。\n\n## 6.使用方法下达命令\n\n向请求URI指定的资源发送请求报文时，采用称为方法的命令。\n\n方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有GET、POST和HEAD等。\n\n下表列出了HTTP/1.0和HTTP/1.1支持的方法。另外方法名区分大小写，注意要用大写字母\n\n| 方法        | 说明                   |  支持的协议版本  |\n| --------    | -----:                 | :----:           |\n| GET         | 获取资源               |   1.0、1.1       |\n| POST        | 传输实体主体           |   1.0、1.1       |\n| PUT         | 传输文件               |   1.0、1.1       |\n| HEAD        | 获得报文首部           |   1.0、1.1       |\n| DELETE      | 删除文件               |   1.0、1.1       |\n| OPTIONS     | 询问支持方法           |   1.1            |\n| TRACE       | 追踪路径               |   1.1            |\n| CONNECT     | 要求用隧道协议连接代理 |   1.1            |\n| LINK        | 建立和资源之间的联系   |   1.0            |\n| UNLINK      | 断开连接关系           |   1.0            |\n\n## 7.持久连接节省通信量\n\nHTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。\n\n![111](img/3.jpeg)\n\n比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此，每次的请求都会造成无谓的TCP链接建立和断开，增加通信量的开销。\n\n![](img/4.jpeg)\n\n### 持久连接\n\n为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（也称为HTTP keep-alive或 HTTP connection reuse）的方法。\n\n持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。\n\n![](img/5.jpeg)\n\n持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。\n\n在HTTP/1.1中，所有的链接默认都是持久连接，但在HTTP/1.0并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。\n\n### 管线化\n\n持久连接使得多数请求以管线化方法发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。\n\n这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。\n\n## 8.使用Cookie 的状态管理\n\nHTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。\n\n假设要求登录认证的页面无法进行状态的管理，那么每次登录都要附加参数来管理登录状态。\n\n当然，无状态协议也有它的优势，由于不必保存状态，自然减少了服务器的CPU及内存资源的小号哦。\n\n> 保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态\n\nCookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段消息，通知客户端保存Cookie.当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去，\n\n**1.请求报文（没有cookie信息的状态）**\n\n```\nGET /reader/ HTTP/1.1\n\nHost:hackr.jp\n*首部字段没有Cookie的相关信息\n```\n\n**2.请求报文（没有cookie信息的状态）**\n\n```\nHTTP /1.1 200 OK\nDate: Thu, 12 Jul 2012 07:12:20 GMT\nServer: Apache\n＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,\n10-Oct-12 07:12:20 GMT＞\nContent-Type: text/plain; charset=UTF-8\n```\n\n**2.请求报文（自动发送保存着的Cookie信息）**\n\n```\nGET /image/ HTTP/1.1\nHost:hackr.jp\nCookie:sid=1342077140226724\n\n```","source":"_posts/HTTP-2.md","raw":"---\ntitle: 《图解HTTP》学习笔记 之 第二章：简单的HTTP协议\ncatalog: true\ndate: 2019-01-15 10:21:40\nsubtitle: 简单的HTTP协议\nheader-img: \"img/header_img/tf-logo-dark.png\"\ntags: \n- 图解HTTP\ncatagories:\n- HTTP\n---\n\n# 第二章：简单的HTTP协议\n> 本章主要对HTTP协议结构进行讲解，主要使用HTTP/1.1\n\n## 1.HTTP协议用于客户端和服务端之间的通信\n\nHTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。\n\n请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。\n\n在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。\n\n## 2.通过请求和响应的交换达成通信\n\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。\n\n\n请求是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。\n\n![请求报文](img/1.jpeg)\n\n图：请求报文的组成\n\n响应报文基本上由协议版本、状态码（标识请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。\n\n![响应报文](img/2.jpeg)\n\n图：响应报文的组成\n\n## 3.HTTP是不保存状态的协议\n\nHTTP是一种不保存的状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。\n\n每当有新的请求时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。\n\nHTTP 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie 技术。\n\n## 4.请求URI定位资源\n\nHTTP协议使用URI定位互联网上的资源，正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。\n\n当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URL包含在内。\n\n除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI，\n\n\n## 5.请求URI定位资源\n\n### GET:获取资源\n\nGET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的是文本，那就保持原样返回；如果是像CGI那样的程序，则返回经过执行后的输出结果。\n\n### POST：传输实体主体\n\nPOST方法用来传输实体的主体\n\n虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输。虽然POST 的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。\n\n### PUT：传输文件\n\nPUT方法用来传输文件。就像FTP协议的文件上传一样，要求再请求报文的主体中包含文件的内容，然后保存到请求URI指定的位置。\n\n> 缺点：但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，一次一般的Web网站不使用该方法。\n\n### HEAD：获取报文首部\n\nHEAD 方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。\n\n### DELETE：删除文件\n\nDELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。\n\n> 缺点：但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般WEB网站也不使用DELETE方法。\n\n### OPTIONS:询问支持的方法。\n\nOPTIONS 方法用来查询针对请求URI指定的资源支持的方法。\n\n### TRACE：追踪路径\n\nTRACE 方法是让Web服务器将之前的请求通信环回给客户端的方法。\n\n发送请求时，在Max-Forwards 首部字段中填入数值，每经过一个服务器就将该数字减1，当数值刚发哦减到0时，就停止继续传输，最后接受到请求的服务器端则返回状态码 200 OK的响应\n\n客户端通过TRACE 方法可以查询发出的请求是怎么样被加工修改/篡改的。这是因为，请求想要连接到原目标服务器可能会通过代理中转，TRACE就是用来确认连接过程中发生的一系列操作。\n\n但是，TRACE方法本来就不常用，再加上它容易引发XST攻击，通常不会用到。\n\n### CONNECT：要求用隧道协议连接代理\n\nCONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。\n\n## 6.使用方法下达命令\n\n向请求URI指定的资源发送请求报文时，采用称为方法的命令。\n\n方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有GET、POST和HEAD等。\n\n下表列出了HTTP/1.0和HTTP/1.1支持的方法。另外方法名区分大小写，注意要用大写字母\n\n| 方法        | 说明                   |  支持的协议版本  |\n| --------    | -----:                 | :----:           |\n| GET         | 获取资源               |   1.0、1.1       |\n| POST        | 传输实体主体           |   1.0、1.1       |\n| PUT         | 传输文件               |   1.0、1.1       |\n| HEAD        | 获得报文首部           |   1.0、1.1       |\n| DELETE      | 删除文件               |   1.0、1.1       |\n| OPTIONS     | 询问支持方法           |   1.1            |\n| TRACE       | 追踪路径               |   1.1            |\n| CONNECT     | 要求用隧道协议连接代理 |   1.1            |\n| LINK        | 建立和资源之间的联系   |   1.0            |\n| UNLINK      | 断开连接关系           |   1.0            |\n\n## 7.持久连接节省通信量\n\nHTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。\n\n![111](img/3.jpeg)\n\n比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此，每次的请求都会造成无谓的TCP链接建立和断开，增加通信量的开销。\n\n![](img/4.jpeg)\n\n### 持久连接\n\n为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（也称为HTTP keep-alive或 HTTP connection reuse）的方法。\n\n持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。\n\n![](img/5.jpeg)\n\n持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。\n\n在HTTP/1.1中，所有的链接默认都是持久连接，但在HTTP/1.0并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。\n\n### 管线化\n\n持久连接使得多数请求以管线化方法发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。\n\n这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。\n\n## 8.使用Cookie 的状态管理\n\nHTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。\n\n假设要求登录认证的页面无法进行状态的管理，那么每次登录都要附加参数来管理登录状态。\n\n当然，无状态协议也有它的优势，由于不必保存状态，自然减少了服务器的CPU及内存资源的小号哦。\n\n> 保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态\n\nCookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段消息，通知客户端保存Cookie.当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去，\n\n**1.请求报文（没有cookie信息的状态）**\n\n```\nGET /reader/ HTTP/1.1\n\nHost:hackr.jp\n*首部字段没有Cookie的相关信息\n```\n\n**2.请求报文（没有cookie信息的状态）**\n\n```\nHTTP /1.1 200 OK\nDate: Thu, 12 Jul 2012 07:12:20 GMT\nServer: Apache\n＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,\n10-Oct-12 07:12:20 GMT＞\nContent-Type: text/plain; charset=UTF-8\n```\n\n**2.请求报文（自动发送保存着的Cookie信息）**\n\n```\nGET /image/ HTTP/1.1\nHost:hackr.jp\nCookie:sid=1342077140226724\n\n```","slug":"HTTP-2","published":1,"updated":"2019-01-15T06:03:45.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqyrrxea0009czhqoms8oph3","content":"<h1><span id=\"第二章简单的http协议\">第二章：简单的HTTP协议</span></h1>\n<blockquote>\n<p>本章主要对HTTP协议结构进行讲解，主要使用HTTP/1.1</p>\n</blockquote>\n<h2><span id=\"1http协议用于客户端和服务端之间的通信\">1.HTTP协议用于客户端和服务端之间的通信</span></h2>\n<p>HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。</p>\n<p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>\n<p>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。</p>\n<h2><span id=\"2通过请求和响应的交换达成通信\">2.通过请求和响应的交换达成通信</span></h2>\n<p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>\n<p>请求是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>\n<p><img src=\"img/1.jpeg\" alt=\"请求报文\"></p>\n<p>图：请求报文的组成</p>\n<p>响应报文基本上由协议版本、状态码（标识请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>\n<p><img src=\"img/2.jpeg\" alt=\"响应报文\"></p>\n<p>图：响应报文的组成</p>\n<h2><span id=\"3http是不保存状态的协议\">3.HTTP是不保存状态的协议</span></h2>\n<p>HTTP是一种不保存的状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。</p>\n<p>每当有新的请求时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。</p>\n<p>HTTP 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie 技术。</p>\n<h2><span id=\"4请求uri定位资源\">4.请求URI定位资源</span></h2>\n<p>HTTP协议使用URI定位互联网上的资源，正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。</p>\n<p>当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URL包含在内。</p>\n<p>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI，</p>\n<h2><span id=\"5请求uri定位资源\">5.请求URI定位资源</span></h2>\n<h3><span id=\"get获取资源\">GET:获取资源</span></h3>\n<p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的是文本，那就保持原样返回；如果是像CGI那样的程序，则返回经过执行后的输出结果。</p>\n<h3><span id=\"post传输实体主体\">POST：传输实体主体</span></h3>\n<p>POST方法用来传输实体的主体</p>\n<p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输。虽然POST 的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p>\n<h3><span id=\"put传输文件\">PUT：传输文件</span></h3>\n<p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求再请求报文的主体中包含文件的内容，然后保存到请求URI指定的位置。</p>\n<blockquote>\n<p>缺点：但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，一次一般的Web网站不使用该方法。</p>\n</blockquote>\n<h3><span id=\"head获取报文首部\">HEAD：获取报文首部</span></h3>\n<p>HEAD 方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p>\n<h3><span id=\"delete删除文件\">DELETE：删除文件</span></h3>\n<p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</p>\n<blockquote>\n<p>缺点：但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般WEB网站也不使用DELETE方法。</p>\n</blockquote>\n<h3><span id=\"options询问支持的方法\">OPTIONS:询问支持的方法。</span></h3>\n<p>OPTIONS 方法用来查询针对请求URI指定的资源支持的方法。</p>\n<h3><span id=\"trace追踪路径\">TRACE：追踪路径</span></h3>\n<p>TRACE 方法是让Web服务器将之前的请求通信环回给客户端的方法。</p>\n<p>发送请求时，在Max-Forwards 首部字段中填入数值，每经过一个服务器就将该数字减1，当数值刚发哦减到0时，就停止继续传输，最后接受到请求的服务器端则返回状态码 200 OK的响应</p>\n<p>客户端通过TRACE 方法可以查询发出的请求是怎么样被加工修改/篡改的。这是因为，请求想要连接到原目标服务器可能会通过代理中转，TRACE就是用来确认连接过程中发生的一系列操作。</p>\n<p>但是，TRACE方法本来就不常用，再加上它容易引发XST攻击，通常不会用到。</p>\n<h3><span id=\"connect要求用隧道协议连接代理\">CONNECT：要求用隧道协议连接代理</span></h3>\n<p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h2><span id=\"6使用方法下达命令\">6.使用方法下达命令</span></h2>\n<p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。</p>\n<p>方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有GET、POST和HEAD等。</p>\n<p>下表列出了HTTP/1.0和HTTP/1.1支持的方法。另外方法名区分大小写，注意要用大写字母</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th style=\"text-align:right\">说明</th>\n<th style=\"text-align:center\">支持的协议版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td style=\"text-align:right\">获取资源</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>POST</td>\n<td style=\"text-align:right\">传输实体主体</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td style=\"text-align:right\">传输文件</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td style=\"text-align:right\">获得报文首部</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td style=\"text-align:right\">删除文件</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td style=\"text-align:right\">询问支持方法</td>\n<td style=\"text-align:center\">1.1</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td style=\"text-align:right\">追踪路径</td>\n<td style=\"text-align:center\">1.1</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td style=\"text-align:right\">要求用隧道协议连接代理</td>\n<td style=\"text-align:center\">1.1</td>\n</tr>\n<tr>\n<td>LINK</td>\n<td style=\"text-align:right\">建立和资源之间的联系</td>\n<td style=\"text-align:center\">1.0</td>\n</tr>\n<tr>\n<td>UNLINK</td>\n<td style=\"text-align:right\">断开连接关系</td>\n<td style=\"text-align:center\">1.0</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"7持久连接节省通信量\">7.持久连接节省通信量</span></h2>\n<p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>\n<p><img src=\"img/3.jpeg\" alt=\"111\"></p>\n<p>比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此，每次的请求都会造成无谓的TCP链接建立和断开，增加通信量的开销。</p>\n<p><img src=\"img/4.jpeg\" alt=\"\"></p>\n<h3><span id=\"持久连接\">持久连接</span></h3>\n<p>为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（也称为HTTP keep-alive或 HTTP connection reuse）的方法。</p>\n<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>\n<p><img src=\"img/5.jpeg\" alt=\"\"></p>\n<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<p>在HTTP/1.1中，所有的链接默认都是持久连接，但在HTTP/1.0并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>\n<h3><span id=\"管线化\">管线化</span></h3>\n<p>持久连接使得多数请求以管线化方法发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>\n<p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p>\n<h2><span id=\"8使用cookie-的状态管理\">8.使用Cookie 的状态管理</span></h2>\n<p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p>\n<p>假设要求登录认证的页面无法进行状态的管理，那么每次登录都要附加参数来管理登录状态。</p>\n<p>当然，无状态协议也有它的优势，由于不必保存状态，自然减少了服务器的CPU及内存资源的小号哦。</p>\n<blockquote>\n<p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p>\n</blockquote>\n<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段消息，通知客户端保存Cookie.当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去，</p>\n<p><strong>1.请求报文（没有cookie信息的状态）</strong></p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/reader/</span> HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">Host:hackr.jp</span></span><br><span class=\"line\"><span class=\"attribute\">*首部字段没有Cookie的相关信息</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.请求报文（没有cookie信息的状态）</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP /1.1 200 OK</span><br><span class=\"line\">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class=\"line\">Server: Apache</span><br><span class=\"line\">＜Set-Cookie: <span class=\"attribute\">sid</span>=1342077140226724; <span class=\"attribute\">path</span>=/; <span class=\"attribute\">expires</span>=Wed,</span><br><span class=\"line\">10-Oct-12 07:12:20 GMT＞</span><br><span class=\"line\">Content-Type: text/plain; <span class=\"attribute\">charset</span>=UTF-8</span><br></pre></td></tr></table></figure>\n<p><strong>2.请求报文（自动发送保存着的Cookie信息）</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">GET</span> /image/ HTTP/1.1</span><br><span class=\"line\">Host:hackr.jp</span><br><span class=\"line\">Cookie:<span class=\"attribute\">sid</span>=1342077140226724</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1>第二章：简单的HTTP协议</h1>\n<blockquote>\n<p>本章主要对HTTP协议结构进行讲解，主要使用HTTP/1.1</p>\n</blockquote>\n<h2>1.HTTP协议用于客户端和服务端之间的通信</h2>\n<p>HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。</p>\n<p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>\n<p>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。</p>\n<h2>2.通过请求和响应的交换达成通信</h2>\n<p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>\n<p>请求是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>\n<p><img src=\"img/1.jpeg\" alt=\"请求报文\"></p>\n<p>图：请求报文的组成</p>\n<p>响应报文基本上由协议版本、状态码（标识请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>\n<p><img src=\"img/2.jpeg\" alt=\"响应报文\"></p>\n<p>图：响应报文的组成</p>\n<h2>3.HTTP是不保存状态的协议</h2>\n<p>HTTP是一种不保存的状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。</p>\n<p>每当有新的请求时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。</p>\n<p>HTTP 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie 技术。</p>\n<h2>4.请求URI定位资源</h2>\n<p>HTTP协议使用URI定位互联网上的资源，正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。</p>\n<p>当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URL包含在内。</p>\n<p>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI，</p>\n<h2>5.请求URI定位资源</h2>\n<h3>GET:获取资源</h3>\n<p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。如果请求的是文本，那就保持原样返回；如果是像CGI那样的程序，则返回经过执行后的输出结果。</p>\n<h3>POST：传输实体主体</h3>\n<p>POST方法用来传输实体的主体</p>\n<p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输。虽然POST 的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p>\n<h3>PUT：传输文件</h3>\n<p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求再请求报文的主体中包含文件的内容，然后保存到请求URI指定的位置。</p>\n<blockquote>\n<p>缺点：但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，一次一般的Web网站不使用该方法。</p>\n</blockquote>\n<h3>HEAD：获取报文首部</h3>\n<p>HEAD 方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p>\n<h3>DELETE：删除文件</h3>\n<p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</p>\n<blockquote>\n<p>缺点：但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般WEB网站也不使用DELETE方法。</p>\n</blockquote>\n<h3>OPTIONS:询问支持的方法。</h3>\n<p>OPTIONS 方法用来查询针对请求URI指定的资源支持的方法。</p>\n<h3>TRACE：追踪路径</h3>\n<p>TRACE 方法是让Web服务器将之前的请求通信环回给客户端的方法。</p>\n<p>发送请求时，在Max-Forwards 首部字段中填入数值，每经过一个服务器就将该数字减1，当数值刚发哦减到0时，就停止继续传输，最后接受到请求的服务器端则返回状态码 200 OK的响应</p>\n<p>客户端通过TRACE 方法可以查询发出的请求是怎么样被加工修改/篡改的。这是因为，请求想要连接到原目标服务器可能会通过代理中转，TRACE就是用来确认连接过程中发生的一系列操作。</p>\n<p>但是，TRACE方法本来就不常用，再加上它容易引发XST攻击，通常不会用到。</p>\n<h3>CONNECT：要求用隧道协议连接代理</h3>\n<p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h2>6.使用方法下达命令</h2>\n<p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。</p>\n<p>方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有GET、POST和HEAD等。</p>\n<p>下表列出了HTTP/1.0和HTTP/1.1支持的方法。另外方法名区分大小写，注意要用大写字母</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th style=\"text-align:right\">说明</th>\n<th style=\"text-align:center\">支持的协议版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td style=\"text-align:right\">获取资源</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>POST</td>\n<td style=\"text-align:right\">传输实体主体</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td style=\"text-align:right\">传输文件</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td style=\"text-align:right\">获得报文首部</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td style=\"text-align:right\">删除文件</td>\n<td style=\"text-align:center\">1.0、1.1</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td style=\"text-align:right\">询问支持方法</td>\n<td style=\"text-align:center\">1.1</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td style=\"text-align:right\">追踪路径</td>\n<td style=\"text-align:center\">1.1</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td style=\"text-align:right\">要求用隧道协议连接代理</td>\n<td style=\"text-align:center\">1.1</td>\n</tr>\n<tr>\n<td>LINK</td>\n<td style=\"text-align:right\">建立和资源之间的联系</td>\n<td style=\"text-align:center\">1.0</td>\n</tr>\n<tr>\n<td>UNLINK</td>\n<td style=\"text-align:right\">断开连接关系</td>\n<td style=\"text-align:center\">1.0</td>\n</tr>\n</tbody>\n</table>\n<h2>7.持久连接节省通信量</h2>\n<p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>\n<p><img src=\"img/3.jpeg\" alt=\"111\"></p>\n<p>比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此，每次的请求都会造成无谓的TCP链接建立和断开，增加通信量的开销。</p>\n<p><img src=\"img/4.jpeg\" alt=\"\"></p>\n<h3>持久连接</h3>\n<p>为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（也称为HTTP keep-alive或 HTTP connection reuse）的方法。</p>\n<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>\n<p><img src=\"img/5.jpeg\" alt=\"\"></p>\n<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<p>在HTTP/1.1中，所有的链接默认都是持久连接，但在HTTP/1.0并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>\n<h3>管线化</h3>\n<p>持久连接使得多数请求以管线化方法发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>\n<p>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p>\n<h2>8.使用Cookie 的状态管理</h2>\n<p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p>\n<p>假设要求登录认证的页面无法进行状态的管理，那么每次登录都要附加参数来管理登录状态。</p>\n<p>当然，无状态协议也有它的优势，由于不必保存状态，自然减少了服务器的CPU及内存资源的小号哦。</p>\n<blockquote>\n<p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态</p>\n</blockquote>\n<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段消息，通知客户端保存Cookie.当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出去，</p>\n<p><strong>1.请求报文（没有cookie信息的状态）</strong></p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/reader/</span> HTTP/1.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">Host:hackr.jp</span></span><br><span class=\"line\"><span class=\"attribute\">*首部字段没有Cookie的相关信息</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.请求报文（没有cookie信息的状态）</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP /1.1 200 OK</span><br><span class=\"line\">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class=\"line\">Server: Apache</span><br><span class=\"line\">＜Set-Cookie: <span class=\"attribute\">sid</span>=1342077140226724; <span class=\"attribute\">path</span>=/; <span class=\"attribute\">expires</span>=Wed,</span><br><span class=\"line\">10-Oct-12 07:12:20 GMT＞</span><br><span class=\"line\">Content-Type: text/plain; <span class=\"attribute\">charset</span>=UTF-8</span><br></pre></td></tr></table></figure>\n<p><strong>2.请求报文（自动发送保存着的Cookie信息）</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">GET</span> /image/ HTTP/1.1</span><br><span class=\"line\">Host:hackr.jp</span><br><span class=\"line\">Cookie:<span class=\"attribute\">sid</span>=1342077140226724</span><br></pre></td></tr></table></figure>"},{"title":"React中使用better-scroll","catalog":true,"date":"2018-08-31T08:04:47.000Z","subtitle":"better-scroll","header-img":"img/header_img/sky.jpg","catagories":["React"],"_content":"# React中使用better-scroll\n\n---------\n\n## 一、better-scroll滚动无效的原因\n### 1.DOM层级关系\n```\n<div class=\"wrapper\">\n  <div class=\"content\">\n    content...\n  </div>\n</div>\n```\n依照作者的说法，wrapper容器里会只对第一个子元素有效。如果多个子元素，一定要将滚动的元素放在第一个位置。\n### 2.content是否被成功添加滚动相关style\n```\n<div className={styles.wrapper}>\n    <ul className={styles.content}>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n</div>\n```\n在审查元素中可以看到ul上已经有对应的style属性\n```\ntransition-timing-function: cubic-bezier(0.165, 0.84, 0.44, 1);\ntransition-duration: 0ms;\ntransform: translate(0px, 0px) scale(1) translateZ(0px);\n```\n### 3.wrapper高度必须大于滚动元素的高度\nlet scroll = new BScroll()\nconsole.log(scroll);在控制台可以看到：\n```\nwrapperHeight:1246 (父级元素的高度)\nscrollerHeight：3849（滚动元素高度）\nhasVerticalScroll：true (是否可以滚动)\n\n```\n以上就是可以滚动的情况，wrapperHeight(1246) < scrollHeight(3849)，hasVerticalScroll为true；\n如果这些数据不对，检查是否dom没有更新完就初始化BScroll了，要等dom更新完才能初始化\n### 4.wrapper的样式\nwrapper要给上定位\n```\nposition: absolute;\nleft: 0;\ntop: 0;\noverflow: hidden;\n\n或者\nposition:relative\n```\n\n## 二、在React中使用better-scroll\n在better-scroll必须在创建完真实DOM之后才能初始化better-scroll,所以在react中需要在componentDidMount或者componentDidUpdate周期中才能初始化better-scroll.\n```\ncomponentDidMount(){\n    let timer = null;\n    if(timer){\n      clearTimeout(timer)\n    }\n    timer = setTimeout(()=>{\n      const content = document.querySelector('#wrapper');\n      let scroll = new BScroll(content,{});\n      console.log(content);\n    },0);\n    console.log(scroll,'scroll');\n}\n```\n以上只是最基本的调用使用，还要在组件销毁时把 BScroll 实例卸载\n\n## 三、封装成一个 Scroll 组件，把内容放在这个组件里\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport {PropTypes} from 'prop-types'\nimport styles from './index.less';\n\nclass Scroll extends React.Component{\n  constructor (props){\n    super(props);\n  }\n  static defaultProps = {\n    click: true, //页面是否可以点击,\n    tap: true,\n    refresh: false, // 刷新Scroll\n    onScroll: null, // scroll 回调事件,\n    scrollTo: null, // 滚动到固定位置\n    initScrollTop:null, //滚动到固定位置之后，回调重置scrollTop\n    pullingDown: null, // 下拉刷新 回调\n    pullingUp: null, // 上拉加载 回调函数\n    scrollToEle: null,\n  }\n  componentDidUpdate(){\n    if(this.bScroll && this.props.refresh === true){\n      this.bScroll.refresh()\n    }\n    if(this.bScroll && this.props.scrollTo === 0 && this.bScroll.y !== 0){\n      this.bScroll.scrollTo(0,this.props.scrollTo)\n      this.props.initScrollTop()\n    }\n    if(this.bScroll && this.props.scrollToEle){\n      this.bScroll.scrollToElement(this.props.scrollToEle,200)\n      this.props.initScrollTop()\n    }\n  }\n  componentDidMount(){\n    this.scrollView = ReactDOM.findDOMNode(this.refs.scrollView);\n    if(!this.bScroll){\n      console.log(this.props.pullDownRefresh,this.props.pullUpLoad);\n      this.bScroll = new BScroll(this.scrollView,{\n        probeType:3,\n        click: this.props.click ? this.iScrollClick(): false,\n        taps: this.props.tap\n      })\n      // 滑动时间\n      if(this.props.onScroll){\n        this.bScroll.on(\"scroll\", (scroll) => {\n          this.props.onScroll(scroll)\n        })\n      }\n      // 下拉刷新\n      if(this.props.pullingDown){\n        this.bScroll.on(\"touchEnd\", (pos) => {\n          if(pos.y > 200){\n            this.props.pullingDown()\n          }\n        })\n      }\n      // 上拉加载\n      if(this.props.pullingUp){\n        this.bScroll.on(\"scrollEnd\", () => {\n          if(this.bScroll.y <= (this.bScroll.maxScrollY + 50)){\n            this.props.pullingUp()\n          }\n        })\n      }\n    }\n  }\n  /**\n   * 解决ios上需要点击两次才能触发点击事件\n   *  */\n  iScrollClick(){\n    if (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) return false;\n    if (/Chrome/i.test(navigator.userAgent)) return (/Android/i.test(navigator.userAgent));\n    if (/Silk/i.test(navigator.userAgent)) return false;\n    if (/Android/i.test(navigator.userAgent)) {\n       var s=navigator.userAgent.substr(navigator.userAgent.indexOf('Android')+8,3);\n       return parseFloat(s[0]+s[3]) < 44 ? false : true\n    }\n  }\n  componentWillUnmount(){\n    this.bScroll.off('scroll');\n    this.bScroll = null;\n  }\n  // 捕获错误\n  componentDidCatch(error,info){\n    console.log(`componentDidCatch:${error}+${info}`);\n  }\n  render(){\n    return (\n      <div className={styles.scrollView} ref=\"scrollView\">\n        {this.props.children}\n      </div>\n    )\n  }\n}\nScroll.propTypes = {\n  click: PropTypes.bool,\n  refresh: PropTypes.bool,\n  pullingDown:PropTypes.func,\n  initScrollTop:PropTypes.func,\n  pullingUp:PropTypes.func,\n  onScroll: PropTypes.func\n}\nexport default Scroll;\n```\nindex.less\n```\n.scrollView{\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}\n```\n\n### 调用组件\n```\nimport React from 'react';\nimport Scroll from 'Scroll'\nclass Content extends React.Component{\n  constructor(){\n    this.state = {\n      refresh: false\n    }\n  }\n  //数据有更新要调用refresh方法\n  componentWillReceiveProps(){\n    this.setState({\n      refresh:true\n    })\n  }\n  //实时滑动事件\n  handleScroll(e){\n    console.log(e)\n  }\n  render(){\n    return(\n      <Scroll \n      refresh={this.state.refresh}\n      onScroll={(e)=>{this.handleScroll(e)}}\n      \n      >\n        <div>\n          ....\n        </div>\n      </Scroll>\n    )\n  }\n}\n\nexport default Content;\n```\n> 在IOS端遇到的兼容性问题\n\n better-scroll 默认会阻止浏览器的原生click事件，我们需要将click属性设为true。\n 问题来了，在IOS端和浏览器模拟器中，即使我们设为false也是可以触发click事件的。如果设为true，我们在IOS端和浏览器模拟器中就需要点击两次才能触发click事件。\n 根据以上特性我们只能根据设备的和浏览器版本信息，动态设置click的值。\n \n ```\n iScrollClick(){\n    if (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) return false;\n    if (/Chrome/i.test(navigator.userAgent)) return (/Android/i.test(navigator.userAgent));\n    if (/Silk/i.test(navigator.userAgent)) return false;\n    if (/Android/i.test(navigator.userAgent)) {\n       var s=navigator.userAgent.substr(navigator.userAgent.indexOf('Android')+8,3);\n       return parseFloat(s[0]+s[3]) < 44 ? false : true\n    }\n  }\n ```\n\n> 最后\n\n我想说的是不管我们使用css的-webkit-overflow-scrolling:touch还是better-scroll（其他iScroll.js等其他第三方库），都会有想不到的问题，实际中我们还是要针对我们自己的项目来选择使用什么方式。","source":"_posts/React.md","raw":"---\ntitle: React中使用better-scroll\ncatalog: true\ndate: 2018-08-31 16:04:47\nsubtitle: 'better-scroll'\nheader-img: \"img/header_img/sky.jpg\"\ntags:\n- React\ncatagories:\n- React\n---\n# React中使用better-scroll\n\n---------\n\n## 一、better-scroll滚动无效的原因\n### 1.DOM层级关系\n```\n<div class=\"wrapper\">\n  <div class=\"content\">\n    content...\n  </div>\n</div>\n```\n依照作者的说法，wrapper容器里会只对第一个子元素有效。如果多个子元素，一定要将滚动的元素放在第一个位置。\n### 2.content是否被成功添加滚动相关style\n```\n<div className={styles.wrapper}>\n    <ul className={styles.content}>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n</div>\n```\n在审查元素中可以看到ul上已经有对应的style属性\n```\ntransition-timing-function: cubic-bezier(0.165, 0.84, 0.44, 1);\ntransition-duration: 0ms;\ntransform: translate(0px, 0px) scale(1) translateZ(0px);\n```\n### 3.wrapper高度必须大于滚动元素的高度\nlet scroll = new BScroll()\nconsole.log(scroll);在控制台可以看到：\n```\nwrapperHeight:1246 (父级元素的高度)\nscrollerHeight：3849（滚动元素高度）\nhasVerticalScroll：true (是否可以滚动)\n\n```\n以上就是可以滚动的情况，wrapperHeight(1246) < scrollHeight(3849)，hasVerticalScroll为true；\n如果这些数据不对，检查是否dom没有更新完就初始化BScroll了，要等dom更新完才能初始化\n### 4.wrapper的样式\nwrapper要给上定位\n```\nposition: absolute;\nleft: 0;\ntop: 0;\noverflow: hidden;\n\n或者\nposition:relative\n```\n\n## 二、在React中使用better-scroll\n在better-scroll必须在创建完真实DOM之后才能初始化better-scroll,所以在react中需要在componentDidMount或者componentDidUpdate周期中才能初始化better-scroll.\n```\ncomponentDidMount(){\n    let timer = null;\n    if(timer){\n      clearTimeout(timer)\n    }\n    timer = setTimeout(()=>{\n      const content = document.querySelector('#wrapper');\n      let scroll = new BScroll(content,{});\n      console.log(content);\n    },0);\n    console.log(scroll,'scroll');\n}\n```\n以上只是最基本的调用使用，还要在组件销毁时把 BScroll 实例卸载\n\n## 三、封装成一个 Scroll 组件，把内容放在这个组件里\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport {PropTypes} from 'prop-types'\nimport styles from './index.less';\n\nclass Scroll extends React.Component{\n  constructor (props){\n    super(props);\n  }\n  static defaultProps = {\n    click: true, //页面是否可以点击,\n    tap: true,\n    refresh: false, // 刷新Scroll\n    onScroll: null, // scroll 回调事件,\n    scrollTo: null, // 滚动到固定位置\n    initScrollTop:null, //滚动到固定位置之后，回调重置scrollTop\n    pullingDown: null, // 下拉刷新 回调\n    pullingUp: null, // 上拉加载 回调函数\n    scrollToEle: null,\n  }\n  componentDidUpdate(){\n    if(this.bScroll && this.props.refresh === true){\n      this.bScroll.refresh()\n    }\n    if(this.bScroll && this.props.scrollTo === 0 && this.bScroll.y !== 0){\n      this.bScroll.scrollTo(0,this.props.scrollTo)\n      this.props.initScrollTop()\n    }\n    if(this.bScroll && this.props.scrollToEle){\n      this.bScroll.scrollToElement(this.props.scrollToEle,200)\n      this.props.initScrollTop()\n    }\n  }\n  componentDidMount(){\n    this.scrollView = ReactDOM.findDOMNode(this.refs.scrollView);\n    if(!this.bScroll){\n      console.log(this.props.pullDownRefresh,this.props.pullUpLoad);\n      this.bScroll = new BScroll(this.scrollView,{\n        probeType:3,\n        click: this.props.click ? this.iScrollClick(): false,\n        taps: this.props.tap\n      })\n      // 滑动时间\n      if(this.props.onScroll){\n        this.bScroll.on(\"scroll\", (scroll) => {\n          this.props.onScroll(scroll)\n        })\n      }\n      // 下拉刷新\n      if(this.props.pullingDown){\n        this.bScroll.on(\"touchEnd\", (pos) => {\n          if(pos.y > 200){\n            this.props.pullingDown()\n          }\n        })\n      }\n      // 上拉加载\n      if(this.props.pullingUp){\n        this.bScroll.on(\"scrollEnd\", () => {\n          if(this.bScroll.y <= (this.bScroll.maxScrollY + 50)){\n            this.props.pullingUp()\n          }\n        })\n      }\n    }\n  }\n  /**\n   * 解决ios上需要点击两次才能触发点击事件\n   *  */\n  iScrollClick(){\n    if (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) return false;\n    if (/Chrome/i.test(navigator.userAgent)) return (/Android/i.test(navigator.userAgent));\n    if (/Silk/i.test(navigator.userAgent)) return false;\n    if (/Android/i.test(navigator.userAgent)) {\n       var s=navigator.userAgent.substr(navigator.userAgent.indexOf('Android')+8,3);\n       return parseFloat(s[0]+s[3]) < 44 ? false : true\n    }\n  }\n  componentWillUnmount(){\n    this.bScroll.off('scroll');\n    this.bScroll = null;\n  }\n  // 捕获错误\n  componentDidCatch(error,info){\n    console.log(`componentDidCatch:${error}+${info}`);\n  }\n  render(){\n    return (\n      <div className={styles.scrollView} ref=\"scrollView\">\n        {this.props.children}\n      </div>\n    )\n  }\n}\nScroll.propTypes = {\n  click: PropTypes.bool,\n  refresh: PropTypes.bool,\n  pullingDown:PropTypes.func,\n  initScrollTop:PropTypes.func,\n  pullingUp:PropTypes.func,\n  onScroll: PropTypes.func\n}\nexport default Scroll;\n```\nindex.less\n```\n.scrollView{\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}\n```\n\n### 调用组件\n```\nimport React from 'react';\nimport Scroll from 'Scroll'\nclass Content extends React.Component{\n  constructor(){\n    this.state = {\n      refresh: false\n    }\n  }\n  //数据有更新要调用refresh方法\n  componentWillReceiveProps(){\n    this.setState({\n      refresh:true\n    })\n  }\n  //实时滑动事件\n  handleScroll(e){\n    console.log(e)\n  }\n  render(){\n    return(\n      <Scroll \n      refresh={this.state.refresh}\n      onScroll={(e)=>{this.handleScroll(e)}}\n      \n      >\n        <div>\n          ....\n        </div>\n      </Scroll>\n    )\n  }\n}\n\nexport default Content;\n```\n> 在IOS端遇到的兼容性问题\n\n better-scroll 默认会阻止浏览器的原生click事件，我们需要将click属性设为true。\n 问题来了，在IOS端和浏览器模拟器中，即使我们设为false也是可以触发click事件的。如果设为true，我们在IOS端和浏览器模拟器中就需要点击两次才能触发click事件。\n 根据以上特性我们只能根据设备的和浏览器版本信息，动态设置click的值。\n \n ```\n iScrollClick(){\n    if (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) return false;\n    if (/Chrome/i.test(navigator.userAgent)) return (/Android/i.test(navigator.userAgent));\n    if (/Silk/i.test(navigator.userAgent)) return false;\n    if (/Android/i.test(navigator.userAgent)) {\n       var s=navigator.userAgent.substr(navigator.userAgent.indexOf('Android')+8,3);\n       return parseFloat(s[0]+s[3]) < 44 ? false : true\n    }\n  }\n ```\n\n> 最后\n\n我想说的是不管我们使用css的-webkit-overflow-scrolling:touch还是better-scroll（其他iScroll.js等其他第三方库），都会有想不到的问题，实际中我们还是要针对我们自己的项目来选择使用什么方式。","slug":"React","published":1,"updated":"2018-12-29T05:54:29.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqyrrxee000cczhqgejk9kmz","content":"<h1><span id=\"react中使用better-scroll\">React中使用better-scroll</span></h1>\n<hr>\n<h2><span id=\"一-better-scroll滚动无效的原因\">一、better-scroll滚动无效的原因</span></h2>\n<h3><span id=\"1dom层级关系\">1.DOM层级关系</span></h3>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">    content...</span><br><span class=\"line\">  &lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>依照作者的说法，wrapper容器里会只对第一个子元素有效。如果多个子元素，一定要将滚动的元素放在第一个位置。</p>\n<h3><span id=\"2content是否被成功添加滚动相关style\">2.content是否被成功添加滚动相关style</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;styles.wrapper&#125;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;styles.content&#125;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在审查元素中可以看到ul上已经有对应的style属性</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">transition-timing-function</span>: cubic-bezier(<span class=\"number\">0.165</span>, <span class=\"number\">0.84</span>, <span class=\"number\">0.44</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"attribute\">transition-duration</span>: <span class=\"number\">0ms</span>;</span><br><span class=\"line\"><span class=\"attribute\">transform</span>: translate(<span class=\"number\">0px</span>, <span class=\"number\">0px</span>) scale(<span class=\"number\">1</span>) translateZ(<span class=\"number\">0px</span>);</span><br></pre></td></tr></table></figure>\n<h3><span id=\"3wrapper高度必须大于滚动元素的高度\">3.wrapper高度必须大于滚动元素的高度</span></h3>\n<p>let scroll = new BScroll()<br>\nconsole.log(scroll);在控制台可以看到：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrapperHeight:<span class=\"number\">1246</span> <span class=\"comment\">(父级元素的高度)</span></span><br><span class=\"line\">scrollerHeight：<span class=\"number\">3849</span>（滚动元素高度）</span><br><span class=\"line\">hasVerticalScroll：true <span class=\"comment\">(是否可以滚动)</span></span><br></pre></td></tr></table></figure>\n<p>以上就是可以滚动的情况，wrapperHeight(1246) &lt; scrollHeight(3849)，hasVerticalScroll为true；<br>\n如果这些数据不对，检查是否dom没有更新完就初始化BScroll了，要等dom更新完才能初始化</p>\n<h3><span id=\"4wrapper的样式\">4.wrapper的样式</span></h3>\n<p>wrapper要给上定位</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\"><span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"><span class=\"attribute\">position</span>:relative</span><br></pre></td></tr></table></figure>\n<h2><span id=\"二-在react中使用better-scroll\">二、在React中使用better-scroll</span></h2>\n<p>在better-scroll必须在创建完真实DOM之后才能初始化better-scroll,所以在react中需要在componentDidMount或者componentDidUpdate周期中才能初始化better-scroll.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(timer)&#123;</span><br><span class=\"line\">      clearTimeout(timer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> content = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#wrapper'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> scroll = <span class=\"keyword\">new</span> BScroll(content,&#123;&#125;);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(content);</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scroll,<span class=\"string\">'scroll'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上只是最基本的调用使用，还要在组件销毁时把 BScroll 实例卸载</p>\n<h2><span id=\"三-封装成一个-scroll-组件把内容放在这个组件里\">三、封装成一个 Scroll 组件，把内容放在这个组件里</span></h2>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React from <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM from <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;PropTypes&#125; from <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> styles from <span class=\"string\">'./index.less'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scroll</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  static defaultProps = &#123;</span><br><span class=\"line\">    click: <span class=\"literal\">true</span>, <span class=\"comment\">//页面是否可以点击,</span></span><br><span class=\"line\">    tap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    refresh: <span class=\"literal\">false</span>, <span class=\"comment\">// 刷新Scroll</span></span><br><span class=\"line\">    onScroll: <span class=\"literal\">null</span>, <span class=\"comment\">// scroll 回调事件,</span></span><br><span class=\"line\">    scrollTo: <span class=\"literal\">null</span>, <span class=\"comment\">// 滚动到固定位置</span></span><br><span class=\"line\">    initScrollTop:<span class=\"literal\">null</span>, <span class=\"comment\">//滚动到固定位置之后，回调重置scrollTop</span></span><br><span class=\"line\">    pullingDown: <span class=\"literal\">null</span>, <span class=\"comment\">// 下拉刷新 回调</span></span><br><span class=\"line\">    pullingUp: <span class=\"literal\">null</span>, <span class=\"comment\">// 上拉加载 回调函数</span></span><br><span class=\"line\">    scrollToEle: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidUpdate()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll &amp;&amp; <span class=\"keyword\">this</span>.props.refresh === <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll.refresh()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll &amp;&amp; <span class=\"keyword\">this</span>.props.scrollTo === <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">this</span>.bScroll.y !== <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll.scrollTo(<span class=\"number\">0</span>,<span class=\"keyword\">this</span>.props.scrollTo)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.initScrollTop()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll &amp;&amp; <span class=\"keyword\">this</span>.props.scrollToEle)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll.scrollToElement(<span class=\"keyword\">this</span>.props.scrollToEle,<span class=\"number\">200</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.initScrollTop()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scrollView = ReactDOM.findDOMNode(<span class=\"keyword\">this</span>.refs.scrollView);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.bScroll)&#123;</span><br><span class=\"line\">      console.log(<span class=\"keyword\">this</span>.props.pullDownRefresh,<span class=\"keyword\">this</span>.props.pullUpLoad);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll = new BScroll(<span class=\"keyword\">this</span>.scrollView,&#123;</span><br><span class=\"line\">        probeType:<span class=\"number\">3</span>,</span><br><span class=\"line\">        click: <span class=\"keyword\">this</span>.props.click ? <span class=\"keyword\">this</span>.iScrollClick(): <span class=\"literal\">false</span>,</span><br><span class=\"line\">        taps: <span class=\"keyword\">this</span>.props.tap</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"comment\">// 滑动时间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.onScroll)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bScroll.on(<span class=\"string\">\"scroll\"</span>, (scroll) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.props.onScroll(scroll)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 下拉刷新</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.pullingDown)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bScroll.on(<span class=\"string\">\"touchEnd\"</span>, (pos) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(pos.y &gt; <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pullingDown()</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 上拉加载</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.pullingUp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bScroll.on(<span class=\"string\">\"scrollEnd\"</span>, () =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll.y &lt;= (<span class=\"keyword\">this</span>.bScroll.maxScrollY + <span class=\"number\">50</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pullingUp()</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 解决ios上需要点击两次才能触发点击事件</span></span><br><span class=\"line\"><span class=\"comment\">   *  */</span></span><br><span class=\"line\">  iScrollClick()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/Chrome/i.test(navigator.userAgent)) <span class=\"keyword\">return</span> (/Android/i.test(navigator.userAgent));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/Silk/i.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/Android/i.test(navigator.userAgent)) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> s=navigator.userAgent.substr(navigator.userAgent.indexOf(<span class=\"string\">'Android'</span>)+<span class=\"number\">8</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> parseFloat(s[<span class=\"number\">0</span>]+s[<span class=\"number\">3</span>]) &lt; <span class=\"number\">44</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bScroll.off(<span class=\"string\">'scroll'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bScroll = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获错误</span></span><br><span class=\"line\">  componentDidCatch(error,info)&#123;</span><br><span class=\"line\">    console.log(`componentDidCatch:$&#123;error&#125;+$&#123;info&#125;`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=&#123;styles.scrollView&#125; ref=<span class=\"string\">\"scrollView\"</span>&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Scroll.propTypes = &#123;</span><br><span class=\"line\">  click: PropTypes.bool,</span><br><span class=\"line\">  refresh: PropTypes.bool,</span><br><span class=\"line\">  pullingDown:PropTypes.func,</span><br><span class=\"line\">  initScrollTop:PropTypes.func,</span><br><span class=\"line\">  pullingUp:PropTypes.func,</span><br><span class=\"line\">  onScroll: PropTypes.func</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export <span class=\"keyword\">default</span> Scroll;</span><br></pre></td></tr></table></figure>\n<p>index.less</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.scrollView</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"调用组件\">调用组件</span></h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Scroll <span class=\"keyword\">from</span> <span class=\"string\">'Scroll'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      refresh: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//数据有更新要调用refresh方法</span></span><br><span class=\"line\">  componentWillReceiveProps()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      refresh:<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//实时滑动事件</span></span><br><span class=\"line\">  handleScroll(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">      &lt;Scroll </span><br><span class=\"line\">      refresh=&#123;<span class=\"keyword\">this</span>.state.refresh&#125;</span><br><span class=\"line\">      onScroll=&#123;(e)=&gt;&#123;<span class=\"keyword\">this</span>.handleScroll(e)&#125;&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          ....</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>Scroll&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Content;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在IOS端遇到的兼容性问题</p>\n</blockquote>\n<p>better-scroll 默认会阻止浏览器的原生click事件，我们需要将click属性设为true。<br>\n问题来了，在IOS端和浏览器模拟器中，即使我们设为false也是可以触发click事件的。如果设为true，我们在IOS端和浏览器模拟器中就需要点击两次才能触发click事件。<br>\n根据以上特性我们只能根据设备的和浏览器版本信息，动态设置click的值。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iScrollClick()&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/iPhone|iPad|iPod|Macintosh/i</span>.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/Chrome/i</span>.test(navigator.userAgent)) <span class=\"keyword\">return</span> (<span class=\"regexp\">/Android/i</span>.test(navigator.userAgent));</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/Silk/i</span>.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/Android/i</span>.test(navigator.userAgent)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s=navigator.userAgent.substr(navigator.userAgent.indexOf(<span class=\"string\">'Android'</span>)+<span class=\"number\">8</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">parseFloat</span>(s[<span class=\"number\">0</span>]+s[<span class=\"number\">3</span>]) &lt; <span class=\"number\">44</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>最后</p>\n</blockquote>\n<p>我想说的是不管我们使用css的-webkit-overflow-scrolling:touch还是better-scroll（其他iScroll.js等其他第三方库），都会有想不到的问题，实际中我们还是要针对我们自己的项目来选择使用什么方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>React中使用better-scroll</h1>\n<hr>\n<h2>一、better-scroll滚动无效的原因</h2>\n<h3>1.DOM层级关系</h3>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><br><span class=\"line\">    content...</span><br><span class=\"line\">  &lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>依照作者的说法，wrapper容器里会只对第一个子元素有效。如果多个子元素，一定要将滚动的元素放在第一个位置。</p>\n<h3>2.content是否被成功添加滚动相关style</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;styles.wrapper&#125;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;styles.content&#125;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在审查元素中可以看到ul上已经有对应的style属性</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">transition-timing-function</span>: cubic-bezier(<span class=\"number\">0.165</span>, <span class=\"number\">0.84</span>, <span class=\"number\">0.44</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"attribute\">transition-duration</span>: <span class=\"number\">0ms</span>;</span><br><span class=\"line\"><span class=\"attribute\">transform</span>: translate(<span class=\"number\">0px</span>, <span class=\"number\">0px</span>) scale(<span class=\"number\">1</span>) translateZ(<span class=\"number\">0px</span>);</span><br></pre></td></tr></table></figure>\n<h3>3.wrapper高度必须大于滚动元素的高度</h3>\n<p>let scroll = new BScroll()<br>\nconsole.log(scroll);在控制台可以看到：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrapperHeight:<span class=\"number\">1246</span> <span class=\"comment\">(父级元素的高度)</span></span><br><span class=\"line\">scrollerHeight：<span class=\"number\">3849</span>（滚动元素高度）</span><br><span class=\"line\">hasVerticalScroll：true <span class=\"comment\">(是否可以滚动)</span></span><br></pre></td></tr></table></figure>\n<p>以上就是可以滚动的情况，wrapperHeight(1246) &lt; scrollHeight(3849)，hasVerticalScroll为true；<br>\n如果这些数据不对，检查是否dom没有更新完就初始化BScroll了，要等dom更新完才能初始化</p>\n<h3>4.wrapper的样式</h3>\n<p>wrapper要给上定位</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\"><span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"><span class=\"attribute\">position</span>:relative</span><br></pre></td></tr></table></figure>\n<h2>二、在React中使用better-scroll</h2>\n<p>在better-scroll必须在创建完真实DOM之后才能初始化better-scroll,所以在react中需要在componentDidMount或者componentDidUpdate周期中才能初始化better-scroll.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(timer)&#123;</span><br><span class=\"line\">      clearTimeout(timer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> content = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#wrapper'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> scroll = <span class=\"keyword\">new</span> BScroll(content,&#123;&#125;);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(content);</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(scroll,<span class=\"string\">'scroll'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上只是最基本的调用使用，还要在组件销毁时把 BScroll 实例卸载</p>\n<h2>三、封装成一个 Scroll 组件，把内容放在这个组件里</h2>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React from <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM from <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;PropTypes&#125; from <span class=\"string\">'prop-types'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> styles from <span class=\"string\">'./index.less'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scroll</span> <span class=\"title\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  static defaultProps = &#123;</span><br><span class=\"line\">    click: <span class=\"literal\">true</span>, <span class=\"comment\">//页面是否可以点击,</span></span><br><span class=\"line\">    tap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    refresh: <span class=\"literal\">false</span>, <span class=\"comment\">// 刷新Scroll</span></span><br><span class=\"line\">    onScroll: <span class=\"literal\">null</span>, <span class=\"comment\">// scroll 回调事件,</span></span><br><span class=\"line\">    scrollTo: <span class=\"literal\">null</span>, <span class=\"comment\">// 滚动到固定位置</span></span><br><span class=\"line\">    initScrollTop:<span class=\"literal\">null</span>, <span class=\"comment\">//滚动到固定位置之后，回调重置scrollTop</span></span><br><span class=\"line\">    pullingDown: <span class=\"literal\">null</span>, <span class=\"comment\">// 下拉刷新 回调</span></span><br><span class=\"line\">    pullingUp: <span class=\"literal\">null</span>, <span class=\"comment\">// 上拉加载 回调函数</span></span><br><span class=\"line\">    scrollToEle: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidUpdate()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll &amp;&amp; <span class=\"keyword\">this</span>.props.refresh === <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll.refresh()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll &amp;&amp; <span class=\"keyword\">this</span>.props.scrollTo === <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">this</span>.bScroll.y !== <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll.scrollTo(<span class=\"number\">0</span>,<span class=\"keyword\">this</span>.props.scrollTo)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.initScrollTop()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll &amp;&amp; <span class=\"keyword\">this</span>.props.scrollToEle)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll.scrollToElement(<span class=\"keyword\">this</span>.props.scrollToEle,<span class=\"number\">200</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.props.initScrollTop()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scrollView = ReactDOM.findDOMNode(<span class=\"keyword\">this</span>.refs.scrollView);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.bScroll)&#123;</span><br><span class=\"line\">      console.log(<span class=\"keyword\">this</span>.props.pullDownRefresh,<span class=\"keyword\">this</span>.props.pullUpLoad);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.bScroll = new BScroll(<span class=\"keyword\">this</span>.scrollView,&#123;</span><br><span class=\"line\">        probeType:<span class=\"number\">3</span>,</span><br><span class=\"line\">        click: <span class=\"keyword\">this</span>.props.click ? <span class=\"keyword\">this</span>.iScrollClick(): <span class=\"literal\">false</span>,</span><br><span class=\"line\">        taps: <span class=\"keyword\">this</span>.props.tap</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"comment\">// 滑动时间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.onScroll)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bScroll.on(<span class=\"string\">\"scroll\"</span>, (scroll) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.props.onScroll(scroll)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 下拉刷新</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.pullingDown)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bScroll.on(<span class=\"string\">\"touchEnd\"</span>, (pos) =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(pos.y &gt; <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pullingDown()</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 上拉加载</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.props.pullingUp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bScroll.on(<span class=\"string\">\"scrollEnd\"</span>, () =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.bScroll.y &lt;= (<span class=\"keyword\">this</span>.bScroll.maxScrollY + <span class=\"number\">50</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.props.pullingUp()</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 解决ios上需要点击两次才能触发点击事件</span></span><br><span class=\"line\"><span class=\"comment\">   *  */</span></span><br><span class=\"line\">  iScrollClick()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/Chrome/i.test(navigator.userAgent)) <span class=\"keyword\">return</span> (/Android/i.test(navigator.userAgent));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/Silk/i.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (/Android/i.test(navigator.userAgent)) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> s=navigator.userAgent.substr(navigator.userAgent.indexOf(<span class=\"string\">'Android'</span>)+<span class=\"number\">8</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> parseFloat(s[<span class=\"number\">0</span>]+s[<span class=\"number\">3</span>]) &lt; <span class=\"number\">44</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillUnmount()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bScroll.off(<span class=\"string\">'scroll'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bScroll = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 捕获错误</span></span><br><span class=\"line\">  componentDidCatch(error,info)&#123;</span><br><span class=\"line\">    console.log(`componentDidCatch:$&#123;error&#125;+$&#123;info&#125;`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div className=&#123;styles.scrollView&#125; ref=<span class=\"string\">\"scrollView\"</span>&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Scroll.propTypes = &#123;</span><br><span class=\"line\">  click: PropTypes.bool,</span><br><span class=\"line\">  refresh: PropTypes.bool,</span><br><span class=\"line\">  pullingDown:PropTypes.func,</span><br><span class=\"line\">  initScrollTop:PropTypes.func,</span><br><span class=\"line\">  pullingUp:PropTypes.func,</span><br><span class=\"line\">  onScroll: PropTypes.func</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export <span class=\"keyword\">default</span> Scroll;</span><br></pre></td></tr></table></figure>\n<p>index.less</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.scrollView</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>调用组件</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Scroll <span class=\"keyword\">from</span> <span class=\"string\">'Scroll'</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      refresh: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//数据有更新要调用refresh方法</span></span><br><span class=\"line\">  componentWillReceiveProps()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      refresh:<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//实时滑动事件</span></span><br><span class=\"line\">  handleScroll(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(</span><br><span class=\"line\">      &lt;Scroll </span><br><span class=\"line\">      refresh=&#123;<span class=\"keyword\">this</span>.state.refresh&#125;</span><br><span class=\"line\">      onScroll=&#123;(e)=&gt;&#123;<span class=\"keyword\">this</span>.handleScroll(e)&#125;&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          ....</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>Scroll&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Content;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在IOS端遇到的兼容性问题</p>\n</blockquote>\n<p>better-scroll 默认会阻止浏览器的原生click事件，我们需要将click属性设为true。<br>\n问题来了，在IOS端和浏览器模拟器中，即使我们设为false也是可以触发click事件的。如果设为true，我们在IOS端和浏览器模拟器中就需要点击两次才能触发click事件。<br>\n根据以上特性我们只能根据设备的和浏览器版本信息，动态设置click的值。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iScrollClick()&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/iPhone|iPad|iPod|Macintosh/i</span>.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/Chrome/i</span>.test(navigator.userAgent)) <span class=\"keyword\">return</span> (<span class=\"regexp\">/Android/i</span>.test(navigator.userAgent));</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/Silk/i</span>.test(navigator.userAgent)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"regexp\">/Android/i</span>.test(navigator.userAgent)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> s=navigator.userAgent.substr(navigator.userAgent.indexOf(<span class=\"string\">'Android'</span>)+<span class=\"number\">8</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">parseFloat</span>(s[<span class=\"number\">0</span>]+s[<span class=\"number\">3</span>]) &lt; <span class=\"number\">44</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>最后</p>\n</blockquote>\n<p>我想说的是不管我们使用css的-webkit-overflow-scrolling:touch还是better-scroll（其他iScroll.js等其他第三方库），都会有想不到的问题，实际中我们还是要针对我们自己的项目来选择使用什么方式。</p>\n"},{"title":"使用 localCompare 排序 在华为微信端出现的bug","catalog":true,"date":"2019-01-09T03:20:09.000Z","subtitle":null,"header-img":"img/header_img/tf-logo-dark.png","catagories":["JavaScript"],"_content":"### 需求及出现的问题\n需求：把一系列数组根据数组中的value的首字母进行排序。\n问题：在华为微信端会出现只循环一次，然后执行报错。其他浏览器和其他手机都没有问题。\n\n### 出现问题的代码\n\n```\nlet arr = [{spell:'A'},{spell:'B'},{spell:'C'}....];\narr.sort((a,b)=>{\n  return a.spell.localeCompare(b.spell)\n})\n```\n### 如何解决\n\n```\narr.sort((a,b)=>{\n  if(a.spell>b.spell){\n    return 1;\n  }else if(a.spell<b.spell){\n    return -1;\n  }else{\n    return 0;\n  }\n})\n```\n","source":"_posts/localCompareBug.md","raw":"---\ntitle: 使用 localCompare 排序 在华为微信端出现的bug\ncatalog: true\ndate: 2019-01-09 11:20:09\nsubtitle:\nheader-img: \"img/header_img/tf-logo-dark.png\"\ntags:\n- bug\ncatagories:\n- JavaScript\n---\n### 需求及出现的问题\n需求：把一系列数组根据数组中的value的首字母进行排序。\n问题：在华为微信端会出现只循环一次，然后执行报错。其他浏览器和其他手机都没有问题。\n\n### 出现问题的代码\n\n```\nlet arr = [{spell:'A'},{spell:'B'},{spell:'C'}....];\narr.sort((a,b)=>{\n  return a.spell.localeCompare(b.spell)\n})\n```\n### 如何解决\n\n```\narr.sort((a,b)=>{\n  if(a.spell>b.spell){\n    return 1;\n  }else if(a.spell<b.spell){\n    return -1;\n  }else{\n    return 0;\n  }\n})\n```\n","slug":"localCompareBug","published":1,"updated":"2019-01-15T06:03:40.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqyrrxeg000eczhqc2k5orwg","content":"<h3><span id=\"需求及出现的问题\">需求及出现的问题</span></h3>\n<p>需求：把一系列数组根据数组中的value的首字母进行排序。<br>\n问题：在华为微信端会出现只循环一次，然后执行报错。其他浏览器和其他手机都没有问题。</p>\n<h3><span id=\"出现问题的代码\">出现问题的代码</span></h3>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [&#123;spell:<span class=\"string\">'A'</span>&#125;,&#123;spell:<span class=\"string\">'B'</span>&#125;,&#123;spell:<span class=\"string\">'C'</span>&#125;....];</span><br><span class=\"line\">arr.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">  return a.spell.localeCompare(b.spell)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"如何解决\">如何解决</span></h3>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"params\">(a,b)</span>=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(a.spell&gt;b.spell)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.spell&lt;b.spell)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3>需求及出现的问题</h3>\n<p>需求：把一系列数组根据数组中的value的首字母进行排序。<br>\n问题：在华为微信端会出现只循环一次，然后执行报错。其他浏览器和其他手机都没有问题。</p>\n<h3>出现问题的代码</h3>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [&#123;spell:<span class=\"string\">'A'</span>&#125;,&#123;spell:<span class=\"string\">'B'</span>&#125;,&#123;spell:<span class=\"string\">'C'</span>&#125;....];</span><br><span class=\"line\">arr.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">  return a.spell.localeCompare(b.spell)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3>如何解决</h3>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"params\">(a,b)</span>=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(a.spell&gt;b.spell)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a.spell&lt;b.spell)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/HTTP-1/img/http-1.jpeg","slug":"img/http-1.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-7.jpeg","slug":"img/http-7.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-2/img/1.jpeg","slug":"img/1.jpeg","post":"cjqyrrxea0009czhqoms8oph3","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-2/img/2.jpeg","slug":"img/2.jpeg","post":"cjqyrrxea0009czhqoms8oph3","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-3/img/1.jpeg","slug":"img/1.jpeg","post":"cjqyrrxdz0003czhqx9u1h4my","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-3/img/4.jpeg","slug":"img/4.jpeg","post":"cjqyrrxdz0003czhqx9u1h4my","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-3/img/2.jpeg","slug":"img/2.jpeg","post":"cjqyrrxdz0003czhqx9u1h4my","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-3/img/5.jpeg","slug":"img/5.jpeg","post":"cjqyrrxdz0003czhqx9u1h4my","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-3.jpeg","slug":"img/http-3.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-2.jpeg","slug":"img/http-2.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-5.jpeg","slug":"img/http-5.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-4.jpeg","slug":"img/http-4.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-6.jpeg","slug":"img/http-6.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-2/img/3.jpeg","slug":"img/3.jpeg","post":"cjqyrrxea0009czhqoms8oph3","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-2/img/4.jpeg","slug":"img/4.jpeg","post":"cjqyrrxea0009czhqoms8oph3","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-2/img/5.jpeg","slug":"img/5.jpeg","post":"cjqyrrxea0009czhqoms8oph3","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-3/img/6.jpeg","slug":"img/6.jpeg","post":"cjqyrrxdz0003czhqx9u1h4my","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/http-8.jpeg","slug":"img/http-8.jpeg","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-3/img/3.jpeg","slug":"img/3.jpeg","post":"cjqyrrxdz0003czhqx9u1h4my","modified":1,"renderable":0},{"_id":"source/_posts/first-blog/img/header_img/heye.jpg","slug":"img/header_img/heye.jpg","post":"cjqyrrxe80008czhqcap4twcy","modified":1,"renderable":0},{"_id":"source/_posts/React/img/header_img/sky.jpg","slug":"img/header_img/sky.jpg","post":"cjqyrrxee000cczhqgejk9kmz","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-1/img/header_img/tf-logo-dark.png","slug":"img/header_img/tf-logo-dark.png","post":"cjqyrrxdt0001czhqtry707ix","modified":1,"renderable":0},{"_id":"source/_posts/HTTP-2/img/header_img/tf-logo-dark.png","slug":"img/header_img/tf-logo-dark.png","post":"cjqyrrxea0009czhqoms8oph3","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjqyrrxdt0001czhqtry707ix","tag_id":"cjqyrrxe30005czhq4859x5kw","_id":"cjqyrrxee000bczhq52aocg6h"},{"post_id":"cjqyrrxea0009czhqoms8oph3","tag_id":"cjqyrrxe30005czhq4859x5kw","_id":"cjqyrrxeg000dczhqfq4tod9c"},{"post_id":"cjqyrrxdz0003czhqx9u1h4my","tag_id":"cjqyrrxe30005czhq4859x5kw","_id":"cjqyrrxei000gczhqrtzpvie6"},{"post_id":"cjqyrrxe50006czhqvwwpfh6t","tag_id":"cjqyrrxeh000fczhq6vo534mj","_id":"cjqyrrxeo000iczhq83f85nx1"},{"post_id":"cjqyrrxe80008czhqcap4twcy","tag_id":"cjqyrrxel000hczhq7gpgwb71","_id":"cjqyrrxes000kczhqc6kxfn2d"},{"post_id":"cjqyrrxee000cczhqgejk9kmz","tag_id":"cjqyrrxer000jczhqigfuu9l2","_id":"cjqyrrxez000mczhqi34mnuis"},{"post_id":"cjqyrrxeg000eczhqc2k5orwg","tag_id":"cjqyrrxew000lczhqmobwbh1r","_id":"cjqyrrxf3000nczhqj6pesaaa"}],"Tag":[{"name":"图解HTTP","_id":"cjqyrrxe30005czhq4859x5kw"},{"name":"前端","_id":"cjqyrrxeh000fczhq6vo534mj"},{"name":"Hexo","_id":"cjqyrrxel000hczhq7gpgwb71"},{"name":"React","_id":"cjqyrrxer000jczhqigfuu9l2"},{"name":"bug","_id":"cjqyrrxew000lczhqmobwbh1r"}]}}